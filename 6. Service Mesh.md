# 6. Service Mesh Manual Deployment

## Overview
Istio service mesh implementation providing traffic management, security, and observability for microservices.

## Prerequisites
- Foundation workflow completed successfully
- Ingress workflow completed successfully
- kubectl configured for the EKS cluster
- Helm 3.x installed
- Optional: LGTM Observability Stack for enhanced monitoring

## Components
- **Istio Control Plane (istiod)**: Service mesh control plane
- **Istio Gateway**: Ingress gateway for external traffic
- **Istio Proxy (Envoy)**: Sidecar proxy for service communication
- **Kiali**: Service mesh observability (optional)
- **Jaeger**: Distributed tracing (optional)

## Manual Deployment Steps

### 1. Create Istio System Namespace
```bash
kubectl create namespace istio-system
kubectl label namespace istio-system app.kubernetes.io/managed-by=manual
```

### 2. Deploy Istio Base (CRDs)
```bash
# Add Istio Helm repository
helm repo add istio https://istio-release.storage.googleapis.com/charts
helm repo update

# Deploy Istio base components (CRDs)
helm install istio-base istio/base \
  --namespace istio-system \
  --version 1.19.3 \
  --set global.istioNamespace=istio-system
```

### 3. Deploy Istio Control Plane (istiod)
```bash
# Deploy istiod control plane
helm install istiod istio/istiod \
  --namespace istio-system \
  --version 1.19.3 \
  --set global.istioNamespace=istio-system \
  --set global.meshID=eks-cluster \
  --set global.network=eks-cluster \
  --set pilot.resources.requests.cpu=100m \
  --set pilot.resources.requests.memory=128Mi \
  --set pilot.resources.limits.cpu=500m \
  --set pilot.resources.limits.memory=2Gi \
  --set pilot.env.EXTERNAL_ISTIOD=false \
  --set pilot.env.PILOT_TRACE_SAMPLING=1.0 \
  --set pilot.env.PILOT_ENABLE_WORKLOAD_ENTRY_AUTOREGISTRATION=true \
  --set pilot.env.PILOT_ENABLE_CROSS_CLUSTER_WORKLOAD_ENTRY=true \
  --set pilot.traceSampling=1.0 \
  --set telemetry.v2.enabled=true \
  --set meshConfig.accessLogFile=/dev/stdout \
  --set meshConfig.defaultConfig.gatewayTopology.numTrustedProxies=2 \
  --set meshConfig.defaultConfig.tracing.sampling=1.0
```

### 4. Wait for Istio CRDs
```bash
# Wait for Istio CRDs to be available
echo "Waiting for Istio CRDs to be installed..."
sleep 60

while ! kubectl get crd gateways.networking.istio.io > /dev/null 2>&1; do
  echo "Waiting for gateways.networking.istio.io CRD..."
  sleep 10
done

while ! kubectl get crd virtualservices.networking.istio.io > /dev/null 2>&1; do
  echo "Waiting for virtualservices.networking.istio.io CRD..."
  sleep 10
done

while ! kubectl get crd destinationrules.networking.istio.io > /dev/null 2>&1; do
  echo "Waiting for destinationrules.networking.istio.io CRD..."
  sleep 10
done

echo "Istio CRDs are now available"
```

### 5. Deploy Istio Ingress Gateway
```bash
# Deploy Istio Gateway
helm install istio-gateway istio/gateway \
  --namespace istio-system \
  --version 1.19.3 \
  --set service.type=LoadBalancer \
  --set service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"=nlb \
  --set service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-cross-zone-load-balancing-enabled"=true \
  --set service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-backend-protocol"=tcp \
  --set resources.requests.cpu=100m \
  --set resources.requests.memory=128Mi \
  --set resources.limits.cpu=2000m \
  --set resources.limits.memory=1024Mi \
  --set autoscaling.enabled=true \
  --set autoscaling.minReplicas=2 \
  --set autoscaling.maxReplicas=4 \
  --set autoscaling.targetCPUUtilizationPercentage=80 \
  --set podDisruptionBudget.minAvailable=1
```

### 6. Create Default Gateway Configuration
```bash
cat <<EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: default-gateway
  namespace: istio-system
spec:
  selector:
    istio: gateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - "*"
    tls:
      httpsRedirect: true
  - port:
      number: 443
      name: https
      protocol: HTTPS
    hosts:
    - "*"
    tls:
      mode: SIMPLE
      credentialName: default-gateway-certs
EOF
```

### 7. Configure mTLS Security
```bash
# Default PeerAuthentication for mTLS
cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT
EOF

# Default DestinationRule for mTLS
cat <<EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: default
  namespace: istio-system
spec:
  host: "*.local"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
EOF
```

### 8. Configure Telemetry
```bash
# Telemetry configuration for observability
cat <<EOF | kubectl apply -f -
apiVersion: telemetry.istio.io/v1alpha1
kind: Telemetry
metadata:
  name: default
  namespace: istio-system
spec:
  metrics:
  - providers:
    - name: prometheus
  tracing:
  - providers:
    - name: tempo
    customTags:
      cluster_name:
        literal:
          value: eks-cluster
      environment:
        literal:
          value: production
  accessLogging:
  - providers:
    - name: otel
EOF
```

### 9. Create Service Monitors (if Prometheus is available)
```bash
# Service Monitor for Istio Control Plane
cat <<EOF | kubectl apply -f -
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: istio-system
  namespace: istio-system
  labels:
    app: istiod
spec:
  selector:
    matchLabels:
      app: istiod
  endpoints:
  - port: http-monitoring
    path: /stats/prometheus
EOF

# Service Monitor for Istio Gateway
cat <<EOF | kubectl apply -f -
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: istio-gateway
  namespace: istio-system
  labels:
    app: istio-gateway
spec:
  selector:
    matchLabels:
      istio: gateway
  endpoints:
  - port: status-port
    path: /stats/prometheus
EOF
```

### 10. Deploy Kiali (Optional)
```bash
# Add Kiali Helm repository
helm repo add kiali https://kiali.org/helm-charts
helm repo update

# Deploy Kiali
helm install kiali-server kiali/kiali-server \
  --namespace istio-system \
  --version 1.74.0 \
  --set auth.strategy=anonymous \
  --set deployment.resources.requests.cpu=100m \
  --set deployment.resources.requests.memory=128Mi \
  --set deployment.resources.limits.cpu=500m \
  --set deployment.resources.limits.memory=1Gi \
  --set external_services.prometheus.url=http://prometheus-kube-prometheus-prometheus.observability.svc.cluster.local:9090 \
  --set external_services.grafana.enabled=true \
  --set external_services.grafana.in_cluster_url=http://grafana.observability.svc.cluster.local:3000 \
  --set external_services.tracing.enabled=true \
  --set external_services.tracing.in_cluster_url=http://tempo-query-frontend.observability.svc.cluster.local:3200 \
  --set server.web_root=/kiali
```

## Verification Steps

### 1. Check Istio Components
```bash
kubectl get pods -n istio-system
kubectl get svc -n istio-system
```

### 2. Verify Istio Installation
```bash
# Check Istio version
kubectl get pods -n istio-system -l app=istiod -o jsonpath='{.items[0].spec.containers[0].image}'

# Check Gateway external IP
kubectl get svc istio-gateway -n istio-system
```

### 3. Check Istio CRDs
```bash
kubectl get crd | grep istio
```

### 4. Test Gateway Connectivity
```bash
# Get gateway external IP
GATEWAY_IP=$(kubectl get svc istio-gateway -n istio-system -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
echo "Gateway URL: http://$GATEWAY_IP"

# Test connectivity
curl -I http://$GATEWAY_IP
```

### 5. Verify mTLS Configuration
```bash
# Check PeerAuthentication
kubectl get peerauthentication -n istio-system

# Check DestinationRule
kubectl get destinationrule -n istio-system
```

### 6. Access Kiali (if deployed)
```bash
# Port-forward to access Kiali UI
kubectl port-forward svc/kiali 20001:20001 -n istio-system

# Access Kiali at http://localhost:20001/kiali
```

## Configuration

### Enable Sidecar Injection for Namespaces
```bash
# Enable automatic sidecar injection for a namespace
kubectl label namespace <namespace> istio-injection=enabled

# Verify injection
kubectl get namespace <namespace> --show-labels
```

### Sample Application with Istio
```yaml
# Deploy sample application
apiVersion: apps/v1
kind: Deployment
metadata:
  name: httpbin
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: httpbin
  template:
    metadata:
      labels:
        app: httpbin
    spec:
      containers:
      - name: httpbin
        image: kennethreitz/httpbin
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: httpbin
  namespace: default
spec:
  selector:
    app: httpbin
  ports:
  - port: 8000
    targetPort: 80
---
# VirtualService for routing
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: httpbin
  namespace: default
spec:
  hosts:
  - httpbin.example.com
  gateways:
  - istio-system/default-gateway
  http:
  - route:
    - destination:
        host: httpbin
        port:
          number: 8000
```

### Traffic Management Examples
```yaml
# Canary deployment with traffic splitting
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: canary-deployment
spec:
  hosts:
  - myapp
  http:
  - match:
    - headers:
        canary:
          exact: "true"
    route:
    - destination:
        host: myapp
        subset: v2
  - route:
    - destination:
        host: myapp
        subset: v1
      weight: 90
    - destination:
        host: myapp
        subset: v2
      weight: 10
---
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: myapp
spec:
  host: myapp
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
```

## Security Configuration

### Authorization Policies
```yaml
# Deny all traffic by default
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: production
spec:
  {}
---
# Allow specific service communication
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  selector:
    matchLabels:
      app: backend
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/production/sa/frontend"]
    to:
    - operation:
        methods: ["GET", "POST"]
```

## Cost Considerations
- **Control Plane**: Minimal overhead ~$10-15/month
- **Gateway**: Load balancer costs ~$20-25/month
- **Sidecar Proxies**: ~10-15% CPU/memory overhead per pod
- **Kiali/Jaeger**: Optional components ~$5-10/month
- **Total estimated cost**: ~$35-50/month

## Troubleshooting

### Istio Control Plane Issues
```bash
# Check istiod logs
kubectl logs -f deployment/istiod -n istio-system

# Check istiod configuration
kubectl exec -n istio-system deployment/istiod -- pilot-discovery proxy-status
```

### Gateway Issues
```bash
# Check gateway logs
kubectl logs -f deployment/istio-gateway -n istio-system

# Check gateway configuration
kubectl describe gateway default-gateway -n istio-system
```

### Sidecar Injection Issues
```bash
# Check if namespace has injection enabled
kubectl get namespace <namespace> --show-labels

# Check sidecar configuration
kubectl get pods <pod-name> -o jsonpath='{.spec.containers[*].name}'

# Manual injection
kubectl apply -f <(istioctl kube-inject -f deployment.yaml)
```

### mTLS Issues
```bash
# Check mTLS status
istioctl authn tls-check <pod-name>.<namespace>

# Verify certificates
istioctl proxy-config secret <pod-name>.<namespace>
```

### Common Issues
1. **Sidecar Not Injected**: Verify namespace labeling and webhook configuration
2. **Gateway Not Accessible**: Check LoadBalancer service and security groups
3. **mTLS Issues**: Verify PeerAuthentication and DestinationRule configurations
4. **High Resource Usage**: Tune proxy resource limits and concurrency

## Cleanup
```bash
helm uninstall kiali-server -n istio-system
helm uninstall istio-gateway -n istio-system
helm uninstall istiod -n istio-system
helm uninstall istio-base -n istio-system
kubectl delete namespace istio-system
```

## Notes
- Istio requires significant cluster resources (recommend 3+ nodes)
- Start with permissive mTLS mode before enforcing strict mode
- Monitor resource usage as sidecar proxies add overhead
- Consider using AWS App Mesh for simpler managed service mesh option