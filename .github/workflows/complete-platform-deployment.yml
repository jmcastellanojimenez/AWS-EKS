name: ðŸš€ Complete Platform Deployment

# MANUAL EXECUTION ONLY - Deploy all 7 workflows in sequence
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      workflows_to_deploy:
        description: 'Workflows to Deploy (comma-separated: 1,2,3,4,5,6,7)'
        required: true
        default: '1,2,3,4,5,6,7'
        type: string
      confirm_deployment:
        description: 'Type "DEPLOY-ALL" to confirm complete platform deployment'
        required: true
        type: string
      skip_validation:
        description: 'Skip prerequisite validation (use with caution)'
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  contents: read

env:
  TF_VERSION: '1.6.0'
  AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}

jobs:
  validate-inputs:
    name: ðŸ” Validate Deployment Request
    runs-on: ubuntu-latest
    outputs:
      should-proceed: ${{ steps.validate.outputs.should-proceed }}
      workflows: ${{ steps.validate.outputs.workflows }}
      environment: ${{ steps.validate.outputs.environment }}
    steps:
      - name: Validate Inputs
        id: validate
        run: |
          # Validate confirmation
          if [[ "${{ inputs.confirm_deployment }}" != "DEPLOY-ALL" ]]; then
            echo "âŒ Complete platform deployment requires 'DEPLOY-ALL' confirmation"
            echo "should-proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Parse and validate workflows
          workflows="${{ inputs.workflows_to_deploy }}"
          workflows=$(echo "$workflows" | tr -d ' ')
          
          # Convert comma-separated list to individual flags
          workflow_1="false"
          workflow_2="false"
          workflow_3="false"
          workflow_4="false"
          workflow_5="false"
          workflow_6="false"
          workflow_7="false"
          
          IFS=',' read -ra WORKFLOW_ARRAY <<< "$workflows"
          for wf in "${WORKFLOW_ARRAY[@]}"; do
            case $wf in
              1) workflow_1="true" ;;
              2) workflow_2="true" ;;
              3) workflow_3="true" ;;
              4) workflow_4="true" ;;
              5) workflow_5="true" ;;
              6) workflow_6="true" ;;
              7) workflow_7="true" ;;
            esac
          done
          
          echo "âœ… Deployment confirmed for environment: ${{ inputs.environment }}"
          echo "âœ… Workflows to deploy: $workflows"
          echo "âœ… Workflow flags: 1=$workflow_1, 2=$workflow_2, 3=$workflow_3, 4=$workflow_4, 5=$workflow_5, 6=$workflow_6, 7=$workflow_7"
          
          echo "should-proceed=true" >> $GITHUB_OUTPUT
          echo "workflows=$workflows" >> $GITHUB_OUTPUT
          echo "workflow-1=$workflow_1" >> $GITHUB_OUTPUT
          echo "workflow-2=$workflow_2" >> $GITHUB_OUTPUT
          echo "workflow-3=$workflow_3" >> $GITHUB_OUTPUT
          echo "workflow-4=$workflow_4" >> $GITHUB_OUTPUT
          echo "workflow-5=$workflow_5" >> $GITHUB_OUTPUT
          echo "workflow-6=$workflow_6" >> $GITHUB_OUTPUT
          echo "workflow-7=$workflow_7" >> $GITHUB_OUTPUT
          echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT

  workflow-1-foundation:
    name: ðŸ—ï¸ Workflow 1 - Foundation Platform
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: validate-inputs
    if: needs.validate-inputs.outputs.should-proceed == 'true' && needs.validate-inputs.outputs.workflow-1 == 'true'
    environment: ${{ needs.validate-inputs.outputs.environment }}
    outputs:
      status: ${{ steps.deploy.outputs.status }}
      cluster-name: ${{ steps.deploy.outputs.cluster-name }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-CompleteDeployment

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸš€ Deploy Foundation Platform
        id: deploy
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          echo "ðŸ—ï¸ Deploying Foundation Platform..."
          terraform init -backend-config="key=eks-platform/${{ needs.validate-inputs.outputs.environment }}/terraform.tfstate"
          terraform plan -out=tfplan -target=module.foundation
          terraform apply -auto-approve tfplan
          
          # Wait for EKS cluster to be ready
          echo "â³ Waiting for EKS cluster to be ready..."
          sleep 120
          
          cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "eks-platform-${{ needs.validate-inputs.outputs.environment }}")
          echo "cluster-name=$cluster_name" >> $GITHUB_OUTPUT
          
          # Verify cluster is accessible
          aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
          kubectl get nodes || (echo "âŒ Cluster not ready" && exit 1)
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Foundation Platform deployed successfully!"

  workflow-2-ingress:
    name: ðŸŒ Workflow 2 - Ingress + API Gateway
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [validate-inputs, workflow-1-foundation]
    if: needs.validate-inputs.outputs.should-proceed == 'true' && needs.validate-inputs.outputs.workflow-2 == 'true' && (needs.validate-inputs.outputs.workflow-1 == 'false' || needs.workflow-1-foundation.outputs.status == 'success')
    environment: ${{ needs.validate-inputs.outputs.environment }}
    outputs:
      status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-CompleteDeployment

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸš€ Deploy Ingress + API Gateway
        id: deploy
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          echo "ðŸŒ Deploying Ingress + API Gateway Stack..."
          terraform init -backend-config="key=eks-platform/${{ needs.validate-inputs.outputs.environment }}/terraform.tfstate"
          terraform plan -out=tfplan -target=module.ingress
          terraform apply -auto-approve tfplan
          
          # Get cluster name from Terraform state or previous workflow
          if [[ "${{ needs.validate-inputs.outputs.workflow-1 }}" == "true" ]]; then
            cluster_name="${{ needs.workflow-1-foundation.outputs.cluster-name }}"
          else
            cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          fi
          
          if [[ -z "$cluster_name" ]]; then
            echo "âŒ Could not determine cluster name"
            exit 1
          fi
          
          echo "âœ… Using cluster: $cluster_name"
          
          # Update kubeconfig first
          aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
          
          # Wait for Ambassador CRDs to be established
          echo "â³ Waiting for Ambassador CRDs to be established..."
          max_attempts=30
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            if kubectl get crd modules.getambassador.io hosts.getambassador.io mappings.getambassador.io 2>/dev/null; then
              echo "âœ… Ambassador CRDs are ready"
              break
            fi
            echo "â³ Waiting for Ambassador CRDs... ($attempt/$max_attempts)"
            sleep 10
            attempt=$((attempt + 1))
          done
          
          # Wait for cert-manager CRDs
          echo "â³ Waiting for cert-manager CRDs..."
          kubectl wait --for condition=established --timeout=300s crd/certificates.cert-manager.io || true
          kubectl wait --for condition=established --timeout=300s crd/clusterissuers.cert-manager.io || true
          
          # Wait for ingress controllers to be ready
          echo "â³ Waiting for ingress controllers..."
          sleep 120
          
          # Verify ingress components
          kubectl wait --for=condition=available --timeout=300s deployment/ambassador -n ingress-system || true
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n ingress-system || true
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Ingress + API Gateway deployed successfully!"

  workflow-3-observability:
    name: ðŸ“ˆ Workflow 3 - LGTM Observability
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: [validate-inputs, workflow-1-foundation, workflow-2-ingress]
    if: needs.validate-inputs.outputs.should-proceed == 'true' && needs.validate-inputs.outputs.workflow-3 == 'true' && (needs.validate-inputs.outputs.workflow-1 == 'false' || needs.workflow-1-foundation.outputs.status == 'success') && (needs.validate-inputs.outputs.workflow-2 == 'false' || needs.workflow-2-ingress.outputs.status == 'success')
    environment: ${{ needs.validate-inputs.outputs.environment }}
    outputs:
      status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-CompleteDeployment

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸš€ Deploy LGTM Observability
        id: deploy
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          echo "ðŸ“ˆ Deploying LGTM Observability Stack..."
          terraform init -backend-config="key=eks-platform/${{ needs.validate-inputs.outputs.environment }}/terraform.tfstate"
          terraform plan -out=tfplan -target=module.lgtm_observability
          terraform apply -auto-approve tfplan
          
          # Get cluster name from Terraform state or previous workflow
          if [[ "${{ needs.validate-inputs.outputs.workflow-1 }}" == "true" ]]; then
            cluster_name="${{ needs.workflow-1-foundation.outputs.cluster-name }}"
          else
            cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          fi
          
          if [[ -z "$cluster_name" ]]; then
            echo "âŒ Could not determine cluster name"
            exit 1
          fi
          
          echo "âœ… Using cluster: $cluster_name"
          
          # Wait for observability components to be ready
          echo "â³ Waiting for observability stack..."
          sleep 240
          
          # Update kubeconfig and verify
          aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
          
          # Verify observability components
          kubectl wait --for=condition=available --timeout=600s deployment/prometheus-server -n observability || true
          kubectl wait --for=condition=available --timeout=300s deployment/grafana -n observability || true
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… LGTM Observability deployed successfully!"

  workflow-4-gitops:
    name: ðŸ”„ Workflow 4 - GitOps & Deployment Automation
    runs-on: ubuntu-latest
    timeout-minutes: 40
    needs: [validate-inputs, workflow-1-foundation, workflow-2-ingress, workflow-3-observability]
    if: needs.validate-inputs.outputs.should-proceed == 'true' && needs.validate-inputs.outputs.workflow-4 == 'true' && (needs.validate-inputs.outputs.workflow-1 == 'false' || needs.workflow-1-foundation.outputs.status == 'success')
    environment: ${{ needs.validate-inputs.outputs.environment }}
    outputs:
      status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-CompleteDeployment

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸš€ Deploy GitOps & Deployment Automation
        id: deploy
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          echo "ðŸ”„ Deploying GitOps & Deployment Automation..."
          terraform init -backend-config="key=eks-platform/${{ needs.validate-inputs.outputs.environment }}/terraform.tfstate"
          terraform plan -out=tfplan -target=module.gitops
          terraform apply -auto-approve tfplan
          
          # Get cluster name from Terraform state or previous workflow
          if [[ "${{ needs.validate-inputs.outputs.workflow-1 }}" == "true" ]]; then
            cluster_name="${{ needs.workflow-1-foundation.outputs.cluster-name }}"
          else
            cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          fi
          
          if [[ -z "$cluster_name" ]]; then
            echo "âŒ Could not determine cluster name"
            exit 1
          fi
          
          echo "âœ… Using cluster: $cluster_name"
          
          # Wait for GitOps components and CRDs to be ready
          echo "â³ Waiting for GitOps components and CRDs..."
          sleep 300
          
          # Update kubeconfig and verify
          aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
          
          # Verify GitOps components and CRDs
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd || true
          
          # Wait for Tekton CRDs to be installed
          max_attempts=30
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            if kubectl get crd pipelines.tekton.dev 2>/dev/null; then
              echo "âœ… Tekton CRDs are ready"
              break
            fi
            echo "â³ Waiting for Tekton CRDs... ($attempt/$max_attempts)"
            sleep 10
            attempt=$((attempt + 1))
          done
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… GitOps & Deployment Automation deployed successfully!"

  workflow-5-security:
    name: ðŸ” Workflow 5 - Security Foundation
    runs-on: ubuntu-latest
    timeout-minutes: 35
    needs: [validate-inputs, workflow-1-foundation, workflow-2-ingress, workflow-3-observability, workflow-4-gitops]
    if: needs.validate-inputs.outputs.should-proceed == 'true' && needs.validate-inputs.outputs.workflow-5 == 'true' && (needs.validate-inputs.outputs.workflow-1 == 'false' || needs.workflow-1-foundation.outputs.status == 'success')
    environment: ${{ needs.validate-inputs.outputs.environment }}
    outputs:
      status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-CompleteDeployment

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸš€ Deploy Security Foundation
        id: deploy
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          echo "ðŸ” Deploying Security Foundation..."
          terraform init -backend-config="key=eks-platform/${{ needs.validate-inputs.outputs.environment }}/terraform.tfstate"
          terraform plan -out=tfplan -target=module.security
          terraform apply -auto-approve tfplan
          
          # Get cluster name from Terraform state or previous workflow
          if [[ "${{ needs.validate-inputs.outputs.workflow-1 }}" == "true" ]]; then
            cluster_name="${{ needs.workflow-1-foundation.outputs.cluster-name }}"
          else
            cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          fi
          
          if [[ -z "$cluster_name" ]]; then
            echo "âŒ Could not determine cluster name"
            exit 1
          fi
          
          echo "âœ… Using cluster: $cluster_name"
          
          # Wait for security components to be ready
          echo "â³ Waiting for security components..."
          sleep 180
          
          # Update kubeconfig and verify
          aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
          
          # Verify security components
          kubectl wait --for=condition=available --timeout=300s deployment/gatekeeper-controller-manager -n gatekeeper-system || true
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Security Foundation deployed successfully!"

  workflow-6-service-mesh:
    name: ðŸ›¡ï¸ Workflow 6 - Service Mesh
    runs-on: ubuntu-latest
    timeout-minutes: 40
    needs: [validate-inputs, workflow-1-foundation, workflow-2-ingress, workflow-3-observability, workflow-5-security]
    if: needs.validate-inputs.outputs.should-proceed == 'true' && needs.validate-inputs.outputs.workflow-6 == 'true' && (needs.validate-inputs.outputs.workflow-1 == 'false' || needs.workflow-1-foundation.outputs.status == 'success')
    environment: ${{ needs.validate-inputs.outputs.environment }}
    outputs:
      status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-CompleteDeployment

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸš€ Deploy Service Mesh
        id: deploy
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          echo "ðŸ›¡ï¸ Deploying Service Mesh..."
          terraform init -backend-config="key=eks-platform/${{ needs.validate-inputs.outputs.environment }}/terraform.tfstate"
          terraform plan -out=tfplan -target=module.service_mesh
          terraform apply -auto-approve tfplan
          
          # Get cluster name from Terraform state or previous workflow
          if [[ "${{ needs.validate-inputs.outputs.workflow-1 }}" == "true" ]]; then
            cluster_name="${{ needs.workflow-1-foundation.outputs.cluster-name }}"
          else
            cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          fi
          
          if [[ -z "$cluster_name" ]]; then
            echo "âŒ Could not determine cluster name"
            exit 1
          fi
          
          echo "âœ… Using cluster: $cluster_name"
          
          # Wait for service mesh components to be ready
          echo "â³ Waiting for service mesh components..."
          sleep 240
          
          # Update kubeconfig and verify
          aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
          
          # Verify service mesh components
          kubectl wait --for=condition=available --timeout=600s deployment/istiod -n istio-system || true
          kubectl wait --for=condition=available --timeout=300s deployment/istio-proxy -n istio-system || true
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Service Mesh deployed successfully!"

  workflow-7-data-services:
    name: ðŸ“Š Workflow 7 - Data Services
    runs-on: ubuntu-latest
    timeout-minutes: 35
    needs: [validate-inputs, workflow-1-foundation, workflow-2-ingress, workflow-3-observability, workflow-4-gitops, workflow-5-security, workflow-6-service-mesh]
    if: needs.validate-inputs.outputs.should-proceed == 'true' && needs.validate-inputs.outputs.workflow-7 == 'true' && (needs.validate-inputs.outputs.workflow-1 == 'false' || needs.workflow-1-foundation.outputs.status == 'success')
    environment: ${{ needs.validate-inputs.outputs.environment }}
    outputs:
      status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-CompleteDeployment

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸš€ Deploy Data Services
        id: deploy
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          echo "ðŸ“Š Deploying Data Services..."
          terraform init -backend-config="key=eks-platform/${{ needs.validate-inputs.outputs.environment }}/terraform.tfstate"
          terraform plan -out=tfplan -target=module.data_services
          terraform apply -auto-approve tfplan
          
          # Get cluster name from Terraform state or previous workflow
          if [[ "${{ needs.validate-inputs.outputs.workflow-1 }}" == "true" ]]; then
            cluster_name="${{ needs.workflow-1-foundation.outputs.cluster-name }}"
          else
            cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          fi
          
          if [[ -z "$cluster_name" ]]; then
            echo "âŒ Could not determine cluster name"
            exit 1
          fi
          
          echo "âœ… Using cluster: $cluster_name"
          
          # Wait for data services to be ready
          echo "â³ Waiting for data services..."
          sleep 300
          
          # Update kubeconfig and verify
          aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
          
          # Verify data services
          kubectl wait --for=condition=ready --timeout=600s pod -l app=postgresql -n data-services || true
          kubectl wait --for=condition=ready --timeout=300s pod -l app=redis -n data-services || true
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Data Services deployed successfully!"

  platform-verification:
    name: ðŸ” Platform Verification
    runs-on: ubuntu-latest
    needs: [validate-inputs, workflow-1-foundation, workflow-2-ingress, workflow-3-observability, workflow-4-gitops, workflow-5-security, workflow-6-service-mesh, workflow-7-data-services]
    if: always() && needs.validate-inputs.outputs.should-proceed == 'true'
    environment: ${{ needs.validate-inputs.outputs.environment }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-CompleteDeployment

      - name: ðŸ”§ Configure kubectl
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          # Get cluster name from Terraform state or previous workflow
          if [[ "${{ needs.validate-inputs.outputs.workflow-1 }}" == "true" ]]; then
            cluster_name="${{ needs.workflow-1-foundation.outputs.cluster-name }}"
          else
            cluster_name=$(terraform init -backend-config="key=eks-platform/${{ needs.validate-inputs.outputs.environment }}/terraform.tfstate" > /dev/null 2>&1 && terraform output -raw cluster_name 2>/dev/null || echo "")
          fi
          
          if [[ -n "$cluster_name" ]]; then
            aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name "$cluster_name"
            echo "âœ… kubectl configured for cluster: $cluster_name"
          else
            echo "âš ï¸ Could not determine cluster name for kubectl configuration"
          fi

      - name: ðŸ” Comprehensive Platform Verification
        run: |
          echo "ðŸ” Verifying Complete Platform Deployment..."
          
          # Check cluster health
          echo "ðŸ—ï¸ Checking Cluster Health..."
          kubectl get nodes
          kubectl get pods -A | grep -E "(Running|Completed)" | wc -l
          
          # Check each workflow deployment
          if [[ "${{ needs.validate-inputs.outputs.workflow-1 }}" == "true" ]]; then
            echo "ðŸ—ï¸ Verifying Foundation Platform..."
            kubectl get nodes --no-headers | wc -l
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-2 }}" == "true" ]]; then
            echo "ðŸŒ Verifying Ingress + API Gateway..."
            kubectl get pods -n cert-manager
            kubectl get pods -n external-dns
            kubectl get pods -n ambassador
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-3 }}" == "true" ]]; then
            echo "ðŸ“ˆ Verifying LGTM Observability..."
            kubectl get pods -n observability
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-4 }}" == "true" ]]; then
            echo "ðŸ”„ Verifying GitOps & Deployment Automation..."
            kubectl get pods -n argocd
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-5 }}" == "true" ]]; then
            echo "ðŸ” Verifying Security Foundation..."
            kubectl get pods -n security
            kubectl get pods -n gatekeeper-system
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-6 }}" == "true" ]]; then
            echo "ðŸ›¡ï¸ Verifying Service Mesh..."
            kubectl get pods -n istio-system
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-7 }}" == "true" ]]; then
            echo "ðŸ“Š Verifying Data Services..."
            kubectl get pods -n data-services
          fi
          
          echo "âœ… Platform verification completed!"

  deployment-summary:
    name: ðŸ“‹ Complete Deployment Summary
    runs-on: ubuntu-latest
    needs: [validate-inputs, workflow-1-foundation, workflow-2-ingress, workflow-3-observability, workflow-4-gitops, workflow-5-security, workflow-6-service-mesh, workflow-7-data-services, platform-verification]
    if: always() && needs.validate-inputs.outputs.should-proceed == 'true'
    steps:
      - name: Generate Complete Platform Summary
        run: |
          echo "## ðŸš€ Complete EKS Platform Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ needs.validate-inputs.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflows Requested**: ${{ needs.validate-inputs.outputs.workflows }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Time**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸ“Š Workflow Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-1 }}" == "true" ]]; then
            echo "- ðŸ—ï¸ **Workflow 1 - Foundation Platform**: ${{ needs.workflow-1-foundation.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-2 }}" == "true" ]]; then
            echo "- ðŸŒ **Workflow 2 - Ingress + API Gateway**: ${{ needs.workflow-2-ingress.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-3 }}" == "true" ]]; then
            echo "- ðŸ“ˆ **Workflow 3 - LGTM Observability**: ${{ needs.workflow-3-observability.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-4 }}" == "true" ]]; then
            echo "- ðŸ”„ **Workflow 4 - GitOps & Deployment Automation**: ${{ needs.workflow-4-gitops.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-5 }}" == "true" ]]; then
            echo "- ðŸ” **Workflow 5 - Security Foundation**: ${{ needs.workflow-5-security.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-6 }}" == "true" ]]; then
            echo "- ðŸ›¡ï¸ **Workflow 6 - Service Mesh**: ${{ needs.workflow-6-service-mesh.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.validate-inputs.outputs.workflow-7 }}" == "true" ]]; then
            echo "- ðŸ“Š **Workflow 7 - Data Services**: ${{ needs.workflow-7-data-services.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ‰ Platform Ready!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Your complete EKS platform is now deployed and ready for the EcoTrack microservices!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Configure kubectl: \`aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name <cluster-name>\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Access Grafana for monitoring" >> $GITHUB_STEP_SUMMARY
          echo "3. Access ArgoCD for GitOps deployments" >> $GITHUB_STEP_SUMMARY
          echo "4. Deploy EcoTrack microservices using the platform" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platform Capabilities:**" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Enterprise-grade Kubernetes cluster" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Complete observability with LGTM stack" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… GitOps-based deployment automation" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Zero-trust security with service mesh" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Production-ready data services" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Cost-optimized with spot instances" >> $GITHUB_STEP_SUMMARY

      - name: Slack Notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#platform-deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}