name: üß™ SA Infra - Ingress Validation

on:
  workflow_dispatch:
    inputs:
      demo_app_urls:
        description: 'Demo app URLs to test (JSON array)'
        required: true
        default: '["https://demo-alb.k8s-demo.local"]'
        type: string
      expected_ingress_classes:
        description: 'Expected ingress classes (JSON array)'
        required: false
        default: '["alb"]'
        type: string
      test_timeout:
        description: 'Test timeout duration'
        required: false
        default: '300s'
        type: string
      cluster_name:
        description: 'EKS Cluster Name'
        required: true
        default: 'eks-learning-lab-dev'
        type: string
  workflow_call:
    inputs:
      demo_app_urls:
        required: true
        type: string
      expected_ingress_classes:
        required: false
        type: string
        default: '["alb"]'
      test_timeout:
        required: false
        type: string
        default: '300s'
      cluster_name:
        required: true
        type: string
    outputs:
      all_tests_passed:
        description: "Whether all tests passed"
        value: ${{ jobs.run-validation.outputs.all_tests_passed }}
      dns_resolution_time:
        description: "Average DNS resolution time"
        value: ${{ jobs.run-validation.outputs.dns_resolution_time }}
      ssl_grade:
        description: "SSL certificate grade"
        value: ${{ jobs.run-validation.outputs.ssl_grade }}
      response_time_p95:
        description: "95th percentile response time"
        value: ${{ jobs.run-validation.outputs.response_time_p95 }}

permissions:
  id-token: write
  contents: read

jobs:
  run-validation:
    name: üß™ Run Validation Tests
    runs-on: ubuntu-latest
    outputs:
      all_tests_passed: ${{ steps.results.outputs.all_tests_passed }}
      dns_resolution_time: ${{ steps.results.outputs.dns_resolution_time }}
      ssl_grade: ${{ steps.results.outputs.ssl_grade }}
      response_time_p95: ${{ steps.results.outputs.response_time_p95 }}
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: SA-IngressValidation

      - name: ‚öôÔ∏è Setup kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ inputs.cluster_name }}

      - name: üéØ Test Ingress Classes
        id: ingress-classes
        run: |
          echo "üéØ Testing ingress classes availability..."
          
          EXPECTED_CLASSES='${{ inputs.expected_ingress_classes }}'
          CLASSES_PASSED=true
          
          # Parse JSON array and test each ingress class
          echo "$EXPECTED_CLASSES" | jq -r '.[]' | while read -r ingress_class; do
            echo "Testing ingress class: $ingress_class"
            
            if [[ "$ingress_class" == "alb" ]]; then
              # Test ALB controller
              if kubectl get deployment aws-load-balancer-controller -n kube-system >/dev/null 2>&1; then
                if kubectl get deployment aws-load-balancer-controller -n kube-system -o jsonpath='{.status.readyReplicas}' | grep -q '^[1-9]'; then
                  echo "‚úÖ ALB controller is ready"
                else
                  echo "‚ùå ALB controller not ready"
                  CLASSES_PASSED=false
                fi
              else
                echo "‚ùå ALB controller not found"
                CLASSES_PASSED=false
              fi
            elif [[ "$ingress_class" == "nginx" ]]; then
              # Test NGINX controller
              if kubectl get deployment ingress-nginx-controller -n ingress-nginx >/dev/null 2>&1; then
                if kubectl get deployment ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.readyReplicas}' | grep -q '^[1-9]'; then
                  echo "‚úÖ NGINX controller is ready"
                else
                  echo "‚ùå NGINX controller not ready"
                  CLASSES_PASSED=false
                fi
              else
                echo "‚ùå NGINX controller not found"
                CLASSES_PASSED=false
              fi
            fi
          done
          
          echo "classes_passed=$CLASSES_PASSED" >> $GITHUB_OUTPUT

      - name: üîí Test Supporting Services
        id: supporting-services
        run: |
          echo "üîí Testing supporting services..."
          
          SERVICES_PASSED=true
          
          # Test cert-manager
          if kubectl get deployment cert-manager -n cert-manager >/dev/null 2>&1; then
            if kubectl get deployment cert-manager -n cert-manager -o jsonpath='{.status.readyReplicas}' | grep -q '^[1-9]'; then
              echo "‚úÖ cert-manager is ready"
            else
              echo "‚ùå cert-manager not ready"
              SERVICES_PASSED=false
            fi
          else
            echo "‚ùå cert-manager not found"
            SERVICES_PASSED=false
          fi
          
          # Test external-dns
          if kubectl get deployment external-dns -n external-dns >/dev/null 2>&1; then
            if kubectl get deployment external-dns -n external-dns -o jsonpath='{.status.readyReplicas}' | grep -q '^[1-9]'; then
              echo "‚úÖ external-dns is ready"
            else
              echo "‚ùå external-dns not ready"
              SERVICES_PASSED=false
            fi
          else
            echo "‚ùå external-dns not found"
            SERVICES_PASSED=false
          fi
          
          # Test ClusterIssuers
          if kubectl get clusterissuer letsencrypt-staging >/dev/null 2>&1; then
            echo "‚úÖ Let's Encrypt staging issuer found"
          else
            echo "‚ùå Let's Encrypt staging issuer not found"
            SERVICES_PASSED=false
          fi
          
          echo "services_passed=$SERVICES_PASSED" >> $GITHUB_OUTPUT

      - name: üåê Test DNS Resolution
        id: dns-test
        run: |
          echo "üåê Testing DNS resolution..."
          
          DEMO_URLS='${{ inputs.demo_app_urls }}'
          DNS_PASSED=true
          TOTAL_TIME=0
          URL_COUNT=0
          
          # Parse JSON array and test each URL
          echo "$DEMO_URLS" | jq -r '.[]' | while read -r url; do
            if [[ -n "$url" ]]; then
              HOSTNAME=$(echo "$url" | sed 's|https\?://||' | sed 's|/.*||')
              echo "Testing DNS for: $HOSTNAME"
              
              START_TIME=$(date +%s%3N)
              if nslookup "$HOSTNAME" >/dev/null 2>&1; then
                END_TIME=$(date +%s%3N)
                RESPONSE_TIME=$((END_TIME - START_TIME))
                echo "‚úÖ $HOSTNAME resolves (${RESPONSE_TIME}ms)"
                TOTAL_TIME=$((TOTAL_TIME + RESPONSE_TIME))
                URL_COUNT=$((URL_COUNT + 1))
              else
                echo "‚ùå $HOSTNAME does not resolve"
                DNS_PASSED=false
              fi
            fi
          done
          
          AVG_TIME=0
          if [[ $URL_COUNT -gt 0 ]]; then
            AVG_TIME=$((TOTAL_TIME / URL_COUNT))
          fi
          
          echo "dns_passed=$DNS_PASSED" >> $GITHUB_OUTPUT
          echo "avg_dns_time=${AVG_TIME}ms" >> $GITHUB_OUTPUT

      - name: üåç Test HTTP Connectivity
        id: http-test
        run: |
          echo "üåç Testing HTTP connectivity..."
          
          DEMO_URLS='${{ inputs.demo_app_urls }}'
          HTTP_PASSED=true
          RESPONSE_TIMES=()
          
          # Parse JSON array and test each URL
          echo "$DEMO_URLS" | jq -r '.[]' | while read -r url; do
            if [[ -n "$url" ]]; then
              echo "Testing HTTP connectivity to: $url"
              
              # Convert HTTPS to HTTP for initial test
              HTTP_URL=$(echo "$url" | sed 's|https://|http://|')
              
              START_TIME=$(date +%s%3N)
              if curl -s --max-time 30 --connect-timeout 10 "$HTTP_URL" >/dev/null 2>&1; then
                END_TIME=$(date +%s%3N)
                RESPONSE_TIME=$((END_TIME - START_TIME))
                echo "‚úÖ $HTTP_URL responds (${RESPONSE_TIME}ms)"
                RESPONSE_TIMES+=("$RESPONSE_TIME")
              else
                echo "‚ùå $HTTP_URL does not respond"
                HTTP_PASSED=false
              fi
            fi
          done
          
          # Calculate P95 response time
          P95_TIME=0
          if [[ ${#RESPONSE_TIMES[@]} -gt 0 ]]; then
            # Simple P95 calculation (sort and take 95th percentile)
            IFS=$'\n' SORTED=($(sort -n <<<"${RESPONSE_TIMES[*]}"))
            P95_INDEX=$(( ${#SORTED[@]} * 95 / 100 ))
            P95_TIME=${SORTED[$P95_INDEX]}
          fi
          
          echo "http_passed=$HTTP_PASSED" >> $GITHUB_OUTPUT
          echo "p95_response_time=${P95_TIME}ms" >> $GITHUB_OUTPUT

      - name: üîê Test HTTPS & SSL Certificates
        id: ssl-test
        run: |
          echo "üîê Testing HTTPS and SSL certificates..."
          
          DEMO_URLS='${{ inputs.demo_app_urls }}'
          SSL_PASSED=true
          SSL_GRADE="N/A"
          
          # Parse JSON array and test each HTTPS URL
          echo "$DEMO_URLS" | jq -r '.[]' | while read -r url; do
            if [[ -n "$url" && "$url" == https* ]]; then
              HOSTNAME=$(echo "$url" | sed 's|https://||' | sed 's|/.*||')
              echo "Testing SSL for: $HOSTNAME"
              
              # Test HTTPS connectivity
              if curl -s --max-time 30 --connect-timeout 10 "$url" >/dev/null 2>&1; then
                echo "‚úÖ HTTPS connection to $url successful"
                
                # Get certificate information
                CERT_INFO=$(openssl s_client -connect "$HOSTNAME:443" -servername "$HOSTNAME" </dev/null 2>/dev/null | openssl x509 -noout -dates -issuer 2>/dev/null || echo "")
                
                if [[ -n "$CERT_INFO" ]]; then
                  echo "üìú Certificate info for $HOSTNAME:"
                  echo "$CERT_INFO"
                  
                  # Check if it's Let's Encrypt
                  if echo "$CERT_INFO" | grep -qi "let's encrypt"; then
                    SSL_GRADE="A"
                    echo "‚úÖ Let's Encrypt certificate detected"
                  elif echo "$CERT_INFO" | grep -qi "staging"; then
                    SSL_GRADE="B"
                    echo "‚ö†Ô∏è Staging certificate detected"
                  else
                    SSL_GRADE="C"
                    echo "‚ÑπÔ∏è Other certificate authority"
                  fi
                fi
              else
                echo "‚ùå HTTPS connection to $url failed"
                SSL_PASSED=false
              fi
            fi
          done
          
          echo "ssl_passed=$SSL_PASSED" >> $GITHUB_OUTPUT
          echo "ssl_grade=$SSL_GRADE" >> $GITHUB_OUTPUT

      - name: üìä Load Balancer Health Check
        id: lb-health
        run: |
          echo "üìä Checking Load Balancer health..."
          
          LB_HEALTH_PASSED=true
          
          # Check ALB health if expected
          EXPECTED_CLASSES='${{ inputs.expected_ingress_classes }}'
          if echo "$EXPECTED_CLASSES" | jq -r '.[]' | grep -q "alb"; then
            echo "Checking ALB health..."
            
            # Get ALB ingress resources
            ALB_INGRESSES=$(kubectl get ingress -o jsonpath='{.items[?(@.spec.ingressClassName=="alb")].metadata.name}' 2>/dev/null || echo "")
            
            if [[ -n "$ALB_INGRESSES" ]]; then
              for ingress in $ALB_INGRESSES; do
                LB_HOSTNAME=$(kubectl get ingress "$ingress" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
                if [[ -n "$LB_HOSTNAME" ]]; then
                  echo "‚úÖ ALB ingress '$ingress' has hostname: $LB_HOSTNAME"
                else
                  echo "‚ùå ALB ingress '$ingress' has no hostname"
                  LB_HEALTH_PASSED=false
                fi
              done
            else
              echo "‚ÑπÔ∏è No ALB ingress resources found"
            fi
          fi
          
          # Check NGINX health if expected
          if echo "$EXPECTED_CLASSES" | jq -r '.[]' | grep -q "nginx"; then
            echo "Checking NGINX health..."
            
            # Get NGINX service
            NGINX_LB=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            
            if [[ -n "$NGINX_LB" ]]; then
              echo "‚úÖ NGINX controller has LoadBalancer: $NGINX_LB"
            else
              echo "‚ùå NGINX controller has no LoadBalancer hostname"
              LB_HEALTH_PASSED=false
            fi
          fi
          
          echo "lb_health_passed=$LB_HEALTH_PASSED" >> $GITHUB_OUTPUT

      - name: üìã Aggregate Results
        id: results
        run: |
          echo "üìã Aggregating test results..."
          
          CLASSES_PASSED="${{ steps.ingress-classes.outputs.classes_passed }}"
          SERVICES_PASSED="${{ steps.supporting-services.outputs.services_passed }}"
          DNS_PASSED="${{ steps.dns-test.outputs.dns_passed }}"
          HTTP_PASSED="${{ steps.http-test.outputs.http_passed }}"
          SSL_PASSED="${{ steps.ssl-test.outputs.ssl_passed }}"
          LB_HEALTH_PASSED="${{ steps.lb-health.outputs.lb_health_passed }}"
          
          ALL_PASSED=true
          
          if [[ "$CLASSES_PASSED" != "true" ]]; then ALL_PASSED=false; fi
          if [[ "$SERVICES_PASSED" != "true" ]]; then ALL_PASSED=false; fi
          if [[ "$DNS_PASSED" != "true" ]]; then ALL_PASSED=false; fi
          if [[ "$HTTP_PASSED" != "true" ]]; then ALL_PASSED=false; fi
          if [[ "$SSL_PASSED" != "true" ]]; then ALL_PASSED=false; fi
          if [[ "$LB_HEALTH_PASSED" != "true" ]]; then ALL_PASSED=false; fi
          
          echo "all_tests_passed=$ALL_PASSED" >> $GITHUB_OUTPUT
          echo "dns_resolution_time=${{ steps.dns-test.outputs.avg_dns_time }}" >> $GITHUB_OUTPUT
          echo "ssl_grade=${{ steps.ssl-test.outputs.ssl_grade }}" >> $GITHUB_OUTPUT
          echo "response_time_p95=${{ steps.http-test.outputs.p95_response_time }}" >> $GITHUB_OUTPUT
          
          echo "üéØ Overall Test Result: $ALL_PASSED"

      - name: üìä Validation Summary
        run: |
          echo "## üß™ SA Ingress Validation - Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster**: ${{ inputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Test Duration**: ${{ inputs.test_timeout }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üéØ Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Individual test results
          if [[ "${{ steps.ingress-classes.outputs.classes_passed }}" == "true" ]]; then
            echo "- ‚úÖ **Ingress Classes**: Available and ready" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå **Ingress Classes**: Issues detected" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.supporting-services.outputs.services_passed }}" == "true" ]]; then
            echo "- ‚úÖ **Supporting Services**: cert-manager, external-dns ready" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå **Supporting Services**: Issues detected" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.dns-test.outputs.dns_passed }}" == "true" ]]; then
            echo "- ‚úÖ **DNS Resolution**: Working (${{ steps.dns-test.outputs.avg_dns_time }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå **DNS Resolution**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.http-test.outputs.http_passed }}" == "true" ]]; then
            echo "- ‚úÖ **HTTP Connectivity**: Working (P95: ${{ steps.http-test.outputs.p95_response_time }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå **HTTP Connectivity**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.ssl-test.outputs.ssl_passed }}" == "true" ]]; then
            echo "- ‚úÖ **SSL Certificates**: Working (Grade: ${{ steps.ssl-test.outputs.ssl_grade }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå **SSL Certificates**: Issues detected" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.lb-health.outputs.lb_health_passed }}" == "true" ]]; then
            echo "- ‚úÖ **Load Balancer Health**: Healthy" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå **Load Balancer Health**: Issues detected" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä Performance Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- **DNS Resolution Time**: ${{ steps.dns-test.outputs.avg_dns_time }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Response Time P95**: ${{ steps.http-test.outputs.p95_response_time }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SSL Grade**: ${{ steps.ssl-test.outputs.ssl_grade }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Overall result
          if [[ "${{ steps.results.outputs.all_tests_passed }}" == "true" ]]; then
            echo "### ‚úÖ **OVERALL RESULT: ALL TESTS PASSED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå **OVERALL RESULT: SOME TESTS FAILED**" >> $GITHUB_STEP_SUMMARY
          fi