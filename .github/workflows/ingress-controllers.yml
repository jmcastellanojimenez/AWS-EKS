name: ğŸ® SA Infra - Ingress Controllers

on:
  workflow_dispatch:
    inputs:
      ingress_pattern:
        description: 'Ingress Pattern to Deploy'
        required: true
        default: 'alb'
        type: choice
        options:
        - alb
        - nginx
        - both
      cluster_name:
        description: 'EKS Cluster Name'
        required: true
        default: 'eks-learning-lab-dev'
        type: string
      domain_name:
        description: 'Domain name for ingress'
        required: true
        type: string
      ssl_email:
        description: 'Email for SSL certificates'
        required: false
        default: 'admin@example.com'
        type: string
      deploy_demo_apps:
        description: 'Deploy Demo Applications'
        required: false
        default: true
        type: boolean
      alb_controller_role_arn:
        description: 'ALB Controller IAM Role ARN'
        required: false
        type: string
      external_dns_role_arn:
        description: 'External-DNS IAM Role ARN'
        required: false
        type: string
      cert_manager_role_arn:
        description: 'cert-manager IAM Role ARN'
        required: false
        type: string
  workflow_call:
    inputs:
      ingress_pattern:
        required: true
        type: string
      cluster_name:
        required: true
        type: string
      domain_name:
        required: true
        type: string
      ssl_email:
        required: false
        type: string
        default: 'admin@example.com'
      deploy_demo_apps:
        required: false
        type: boolean
        default: true
      alb_controller_role_arn:
        required: false
        type: string
      external_dns_role_arn:
        required: false
        type: string
      cert_manager_role_arn:
        required: false
        type: string
    outputs:
      ingress_class_alb:
        description: "ALB ingress class name"
        value: ${{ jobs.deploy-controllers.outputs.ingress_class_alb }}
      ingress_class_nginx:
        description: "NGINX ingress class name"
        value: ${{ jobs.deploy-controllers.outputs.ingress_class_nginx }}
      demo_app_urls:
        description: "Demo application URLs"
        value: ${{ jobs.deploy-controllers.outputs.demo_app_urls }}

permissions:
  id-token: write
  contents: read

jobs:
  verify-dependencies:
    name: ğŸ” Verify Dependencies
    runs-on: ubuntu-latest
    outputs:
      cluster_accessible: ${{ steps.verify.outputs.cluster_accessible }}
    steps:
      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: SA-IngressControllers

      - name: âš™ï¸ Setup kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/

      - name: ğŸ” Verify EKS Cluster Access
        id: verify
        run: |
          echo "ğŸ” Configuring kubectl for cluster: ${{ inputs.cluster_name }}"
          
          if aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ inputs.cluster_name }}; then
            echo "âœ… kubectl configured successfully"
            
            if kubectl cluster-info >/dev/null 2>&1; then
              echo "âœ… Cluster accessible"
              kubectl get nodes
              kubectl version --client --short
              echo "cluster_accessible=true" >> $GITHUB_OUTPUT
            else
              echo "âŒ Cannot access cluster"
              echo "cluster_accessible=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "âŒ Failed to configure kubectl"
            echo "cluster_accessible=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  deploy-controllers:
    name: ğŸ® Deploy Kubernetes Controllers
    runs-on: ubuntu-latest
    needs: verify-dependencies
    if: needs.verify-dependencies.outputs.cluster_accessible == 'true'
    outputs:
      ingress_class_alb: ${{ steps.outputs.outputs.ingress_class_alb }}
      ingress_class_nginx: ${{ steps.outputs.outputs.ingress_class_nginx }}
      demo_app_urls: ${{ steps.outputs.outputs.demo_app_urls }}
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: SA-IngressControllers

      - name: âš™ï¸ Setup Tools
        run: |
          # kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          
          # Configure kubectl
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ inputs.cluster_name }}

      - name: ğŸ› ï¸ Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: ğŸ“¦ Add Helm Repositories
        run: |
          echo "ğŸ“¦ Adding Helm repositories..."
          helm repo add jetstack https://charts.jetstack.io
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo add eks https://aws.github.io/eks-charts
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update

      - name: ğŸ”’ Deploy cert-manager
        run: |
          echo "ğŸ”’ Installing cert-manager..."
          
          # Create namespace
          kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
          
          # Install cert-manager
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --set installCRDs=true \
            --set serviceAccount.create=true \
            --set serviceAccount.name=cert-manager \
            --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"="${{ inputs.cert_manager_role_arn }}" \
            --wait --timeout=300s

      - name: ğŸŒ Deploy External-DNS
        run: |
          echo "ğŸŒ Installing External-DNS..."
          
          # Create namespace
          kubectl create namespace external-dns --dry-run=client -o yaml | kubectl apply -f -
          
          # Install external-dns
          helm upgrade --install external-dns bitnami/external-dns \
            --namespace external-dns \
            --set provider=aws \
            --set aws.region=${{ secrets.AWS_REGION }} \
            --set domainFilters[0]=${{ inputs.domain_name }} \
            --set serviceAccount.create=true \
            --set serviceAccount.name=external-dns \
            --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"="${{ inputs.external_dns_role_arn }}" \
            --set logLevel=info \
            --wait --timeout=300s

      - name: ğŸ¯ Deploy ALB Controller
        if: inputs.ingress_pattern == 'alb' || inputs.ingress_pattern == 'both'
        run: |
          echo "ğŸ¯ Installing AWS Load Balancer Controller..."
          
          # Create ServiceAccount
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            labels:
              app.kubernetes.io/component: controller
              app.kubernetes.io/name: aws-load-balancer-controller
            name: aws-load-balancer-controller
            namespace: kube-system
            annotations:
              eks.amazonaws.com/role-arn: ${{ inputs.alb_controller_role_arn }}
          EOF
          
          # Install ALB Controller
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            --namespace kube-system \
            --set clusterName=${{ inputs.cluster_name }} \
            --set serviceAccount.create=false \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set region=${{ secrets.AWS_REGION }} \
            --wait --timeout=300s
          
          echo "âœ… ALB Controller deployed"

      - name: ğŸ”µ Deploy NGINX Controller
        if: inputs.ingress_pattern == 'nginx' || inputs.ingress_pattern == 'both'
        run: |
          echo "ğŸ”µ Installing NGINX Ingress Controller..."
          
          # Create namespace
          kubectl create namespace ingress-nginx --dry-run=client -o yaml | kubectl apply -f -
          
          # Install NGINX Controller
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --set controller.service.type=LoadBalancer \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-cross-zone-load-balancing-enabled"="true" \
            --wait --timeout=300s
          
          echo "âœ… NGINX Controller deployed"

      - name: ğŸ‰ Deploy Demo Applications
        if: inputs.deploy_demo_apps == true
        run: |
          echo "ğŸ‰ Deploying demo applications..."
          
          # Deploy demo apps
          kubectl apply -f k8s/demo-apps/
          
          # Wait for deployments
          kubectl rollout status deployment/pink-demo-app -n default --timeout=300s
          kubectl rollout status deployment/purple-demo-app -n default --timeout=300s
          
          echo "âœ… Demo applications deployed"

      - name: ğŸ“‹ Deploy cert-manager ClusterIssuers
        run: |
          echo "ğŸ“‹ Creating cert-manager ClusterIssuers..."
          
          # Create ClusterIssuers
          kubectl apply -f - <<EOF
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-staging
          spec:
            acme:
              server: https://acme-staging-v02.api.letsencrypt.org/directory
              email: ${{ inputs.ssl_email }}
              privateKeySecretRef:
                name: letsencrypt-staging
              solvers:
              - http01:
                  ingress:
                    ingressTemplate:
                      metadata:
                        annotations:
                          kubernetes.io/ingress.class: "alb"
                          alb.ingress.kubernetes.io/scheme: internet-facing
                          alb.ingress.kubernetes.io/target-type: ip
          ---
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: ${{ inputs.ssl_email }}
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
              - http01:
                  ingress:
                    ingressTemplate:
                      metadata:
                        annotations:
                          kubernetes.io/ingress.class: "alb"
                          alb.ingress.kubernetes.io/scheme: internet-facing
                          alb.ingress.kubernetes.io/target-type: ip
          EOF
          
          echo "âœ… ClusterIssuers created"

      - name: ğŸ“Š Wait for Controllers Ready
        run: |
          echo "ğŸ“Š Waiting for controllers to be ready..."
          
          # Wait for cert-manager
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n cert-manager
          
          # Wait for external-dns
          kubectl wait --for=condition=available --timeout=300s deployment/external-dns -n external-dns
          
          # Wait for ALB controller (if deployed)
          if [[ "${{ inputs.ingress_pattern }}" == "alb" || "${{ inputs.ingress_pattern }}" == "both" ]]; then
            kubectl wait --for=condition=available --timeout=300s deployment/aws-load-balancer-controller -n kube-system
          fi
          
          # Wait for NGINX controller (if deployed)
          if [[ "${{ inputs.ingress_pattern }}" == "nginx" || "${{ inputs.ingress_pattern }}" == "both" ]]; then
            kubectl wait --for=condition=available --timeout=300s deployment/ingress-nginx-controller -n ingress-nginx
          fi
          
          echo "âœ… All controllers ready"

      - name: ğŸ“Š Set Outputs
        id: outputs
        run: |
          # Set ingress classes
          if [[ "${{ inputs.ingress_pattern }}" == "alb" || "${{ inputs.ingress_pattern }}" == "both" ]]; then
            echo "ingress_class_alb=alb" >> $GITHUB_OUTPUT
          fi
          
          if [[ "${{ inputs.ingress_pattern }}" == "nginx" || "${{ inputs.ingress_pattern }}" == "both" ]]; then
            echo "ingress_class_nginx=nginx" >> $GITHUB_OUTPUT
          fi
          
          # Set demo app URLs (if deployed)
          if [[ "${{ inputs.deploy_demo_apps }}" == "true" ]]; then
            DEMO_URLS='["https://demo-alb.${{ inputs.domain_name }}", "https://demo-nginx.${{ inputs.domain_name }}"]'
            echo "demo_app_urls=$DEMO_URLS" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“‹ Controllers Summary
        run: |
          echo "## ğŸ® SA Ingress Controllers - Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster**: ${{ inputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Pattern**: ${{ inputs.ingress_pattern }}" >> $GITHUB_STEP_SUMMARY
          echo "**Domain**: ${{ inputs.domain_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ® Deployed Controllers" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ inputs.ingress_pattern }}" == "alb" || "${{ inputs.ingress_pattern }}" == "both" ]]; then
            echo "- âœ… **AWS Load Balancer Controller** (ALB)" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ inputs.ingress_pattern }}" == "nginx" || "${{ inputs.ingress_pattern }}" == "both" ]]; then
            echo "- âœ… **NGINX Ingress Controller**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "- âœ… **cert-manager** (SSL certificates)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… **external-dns** (Route53 integration)" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ inputs.deploy_demo_apps }}" == "true" ]]; then
            echo "- âœ… **Demo Applications**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Deploy ingress resources for your applications" >> $GITHUB_STEP_SUMMARY
          echo "2. Run **SA Infra - Ingress Validation** to test connectivity" >> $GITHUB_STEP_SUMMARY