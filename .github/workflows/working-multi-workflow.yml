name: üöÄ Working Multi-Workflow Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      workflows_to_deploy:
        description: 'Workflows to Deploy (comma-separated: 1,2,3,4,5,6,7)'
        required: true
        default: '2,3,4,5,6,7'
        type: string
      confirm_deployment:
        description: 'Type "DEPLOY-ALL" to confirm deployment'
        required: true
        type: string

permissions:
  id-token: write
  contents: read

env:
  TF_VERSION: '1.6.0'
  AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}

jobs:
  deploy-workflows:
    name: üöÄ Deploy Selected Workflows
    runs-on: ubuntu-latest
    timeout-minutes: 300
    environment: ${{ inputs.environment }}
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîç Validate and Parse Input
        id: validate
        run: |
          # Validate confirmation
          if [[ "${{ inputs.confirm_deployment }}" != "DEPLOY-ALL" ]]; then
            echo "‚ùå Deployment requires 'DEPLOY-ALL' confirmation"
            exit 1
          fi
          
          # Parse workflows
          workflows="${{ inputs.workflows_to_deploy }}"
          workflows=$(echo "$workflows" | tr -d ' ')
          echo "‚úÖ Will deploy workflows: $workflows"
          
          # Create flags
          deploy_1="false"
          deploy_2="false"
          deploy_3="false"
          deploy_4="false"
          deploy_5="false"
          deploy_6="false"
          deploy_7="false"
          
          IFS=',' read -ra WORKFLOW_ARRAY <<< "$workflows"
          for wf in "${WORKFLOW_ARRAY[@]}"; do
            case $wf in
              1) deploy_1="true" ;;
              2) deploy_2="true" ;;
              3) deploy_3="true" ;;
              4) deploy_4="true" ;;
              5) deploy_5="true" ;;
              6) deploy_6="true" ;;
              7) deploy_7="true" ;;
            esac
          done
          
          echo "deploy-1=$deploy_1" >> $GITHUB_OUTPUT
          echo "deploy-2=$deploy_2" >> $GITHUB_OUTPUT
          echo "deploy-3=$deploy_3" >> $GITHUB_OUTPUT
          echo "deploy-4=$deploy_4" >> $GITHUB_OUTPUT
          echo "deploy-5=$deploy_5" >> $GITHUB_OUTPUT
          echo "deploy-6=$deploy_6" >> $GITHUB_OUTPUT
          echo "deploy-7=$deploy_7" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Workflow flags: 1=$deploy_1, 2=$deploy_2, 3=$deploy_3, 4=$deploy_4, 5=$deploy_5, 6=$deploy_6, 7=$deploy_7"

      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-WorkingDeployment

      - name: üèóÔ∏è Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: üèóÔ∏è Workflow 1 - Foundation Platform
        if: steps.validate.outputs.deploy-1 == 'true'
        working-directory: terraform/environments/${{ inputs.environment }}
        run: |
          echo "üèóÔ∏è Deploying Foundation Platform..."
          terraform init -reconfigure -backend-config="bucket=eks-learning-lab-terraform-state-${{ secrets.AWS_ACCOUNT_ID }}" -backend-config="key=eks-platform/${{ inputs.environment }}/terraform.tfstate" -backend-config="region=us-east-1"
          terraform plan -out=tfplan -target=module.foundation -target=module.observability_irsa_roles -target=aws_iam_policy.observability_s3_policy
          terraform apply -auto-approve tfplan
          
          # Verify EKS cluster and nodes are ready
          cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          if [[ -n "$cluster_name" ]]; then
            echo "‚è≥ Configuring kubectl and waiting for nodes..."
            aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
            
            # Wait for nodes to be ready (max 5 minutes)
            echo "‚è≥ Waiting for nodes to join cluster..."
            max_attempts=30
            attempt=1
            while [ $attempt -le $max_attempts ]; do
              ready_nodes=$(kubectl get nodes --no-headers 2>/dev/null | grep -c Ready || echo "0")
              if [ "$ready_nodes" -ge "2" ]; then
                echo "‚úÖ $ready_nodes nodes are ready"
                kubectl get nodes
                break
              fi
              echo "‚è≥ Waiting for nodes... ($ready_nodes ready, attempt $attempt/$max_attempts)"
              sleep 10
              attempt=$((attempt + 1))
            done
          fi
          echo "‚úÖ Foundation Platform deployed!"

      - name: üåê Workflow 2 - Ingress + API Gateway
        if: steps.validate.outputs.deploy-2 == 'true'
        working-directory: terraform/environments/${{ inputs.environment }}
        run: |
          echo "üåê Deploying Ingress + API Gateway..."
          terraform init -reconfigure -backend-config="bucket=eks-learning-lab-terraform-state-${{ secrets.AWS_ACCOUNT_ID }}" -backend-config="key=eks-platform/${{ inputs.environment }}/terraform.tfstate" -backend-config="region=us-east-1"
          terraform plan -out=tfplan -target=module.ingress
          terraform apply -auto-approve tfplan
          
          # Get cluster name and configure kubectl
          cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          if [[ -n "$cluster_name" ]]; then
            aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
            
            # Wait for Ambassador CRDs
            echo "‚è≥ Waiting for Ambassador CRDs..."
            max_attempts=30
            attempt=1
            while [ $attempt -le $max_attempts ]; do
              if kubectl get crd modules.getambassador.io hosts.getambassador.io mappings.getambassador.io 2>/dev/null; then
                echo "‚úÖ Ambassador CRDs are ready"
                break
              fi
              echo "‚è≥ Waiting for Ambassador CRDs... ($attempt/$max_attempts)"
              sleep 10
              attempt=$((attempt + 1))
            done
            
            # Verify components
            kubectl wait --for=condition=available --timeout=300s deployment/ambassador -n ingress-system || true
            kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n ingress-system || true
          fi
          echo "‚úÖ Ingress + API Gateway deployed!"

      - name: üìà Workflow 3 - LGTM Observability
        if: steps.validate.outputs.deploy-3 == 'true'
        working-directory: terraform/environments/${{ inputs.environment }}/03-lgtm
        run: |
          echo "üìà Deploying LGTM Observability..."
          terraform init -reconfigure -backend-config="bucket=eks-learning-lab-terraform-state-${{ secrets.AWS_ACCOUNT_ID }}" -backend-config="key=eks-platform/${{ inputs.environment }}/lgtm-terraform.tfstate" -backend-config="region=us-east-1"
          
          # Deploy standalone LGTM stack (Prometheus + Grafana only)
          echo "üîß Deploying standalone LGTM configuration..."
          terraform plan -out=tfplan
          terraform apply -auto-approve tfplan
          
          # Get cluster name from convention
          cluster_name="eks-platform-${{ inputs.environment }}-cluster"
          if [[ -n "$cluster_name" ]]; then
            aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
            
            # Check pod status before waiting
            echo "üìä Checking LGTM pod status..."
            kubectl get pods -n observability || true
            kubectl get deployments -n observability || true
            
            # Check node resources
            echo "üìä Checking node resources..."
            kubectl top nodes || true
            kubectl get nodes -o wide || true
            
            # Only wait for MINIMAL enabled components (Prometheus and Grafana only)
            echo "‚è≥ Waiting for Prometheus (MINIMAL LGTM)..."
            kubectl wait --for=condition=available --timeout=180s deployment/prometheus-server -n observability || echo "‚ö†Ô∏è Prometheus not ready yet"
            
            echo "‚è≥ Waiting for Grafana (MINIMAL LGTM)..."  
            kubectl wait --for=condition=available --timeout=180s deployment/grafana -n observability || echo "‚ö†Ô∏è Grafana not ready yet"
            
            # Final verification - should only see Prometheus + Grafana
            echo "‚úÖ MINIMAL LGTM stack status (should only see Prometheus + Grafana):"
            kubectl get pods -n observability --show-labels
            kubectl get svc -n observability
            
            echo "üöÄ MINIMAL LGTM deployment complete - ready for workflows 4-7!"
          fi
          echo "‚úÖ LGTM Observability deployed!"

      - name: üîÑ Workflow 4 - GitOps & Deployment Automation
        if: steps.validate.outputs.deploy-4 == 'true'
        working-directory: terraform/environments/${{ inputs.environment }}
        run: |
          echo "üîÑ Deploying GitOps & Deployment Automation..."
          terraform init -reconfigure -backend-config="bucket=eks-learning-lab-terraform-state-${{ secrets.AWS_ACCOUNT_ID }}" -backend-config="key=eks-platform/${{ inputs.environment }}/terraform.tfstate" -backend-config="region=us-east-1"
          terraform plan -out=tfplan -target=module.gitops
          terraform apply -auto-approve tfplan
          
          # Get cluster name and verify
          cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          if [[ -n "$cluster_name" ]]; then
            aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
            sleep 180
            kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd || true
          fi
          echo "‚úÖ GitOps & Deployment Automation deployed!"

      - name: üîê Workflow 5 - Security Foundation
        if: steps.validate.outputs.deploy-5 == 'true'
        working-directory: terraform/environments/${{ inputs.environment }}
        run: |
          echo "üîê Deploying Security Foundation..."
          terraform init -reconfigure -backend-config="bucket=eks-learning-lab-terraform-state-${{ secrets.AWS_ACCOUNT_ID }}" -backend-config="key=eks-platform/${{ inputs.environment }}/terraform.tfstate" -backend-config="region=us-east-1"
          terraform plan -out=tfplan -target=module.security
          terraform apply -auto-approve tfplan
          
          # Get cluster name and verify
          cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          if [[ -n "$cluster_name" ]]; then
            aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
            sleep 120
            kubectl wait --for=condition=available --timeout=300s deployment/gatekeeper-controller-manager -n gatekeeper-system || true
          fi
          echo "‚úÖ Security Foundation deployed!"

      - name: üõ°Ô∏è Workflow 6 - Service Mesh
        if: steps.validate.outputs.deploy-6 == 'true'
        working-directory: terraform/environments/${{ inputs.environment }}
        run: |
          echo "üõ°Ô∏è Deploying Service Mesh..."
          terraform init -reconfigure -backend-config="bucket=eks-learning-lab-terraform-state-${{ secrets.AWS_ACCOUNT_ID }}" -backend-config="key=eks-platform/${{ inputs.environment }}/terraform.tfstate" -backend-config="region=us-east-1"
          terraform plan -out=tfplan -target=module.service_mesh
          terraform apply -auto-approve tfplan
          
          # Get cluster name and verify
          cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          if [[ -n "$cluster_name" ]]; then
            aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
            sleep 180
            kubectl wait --for=condition=available --timeout=600s deployment/istiod -n istio-system || true
          fi
          echo "‚úÖ Service Mesh deployed!"

      - name: üìä Workflow 7 - Data Services
        if: steps.validate.outputs.deploy-7 == 'true'
        working-directory: terraform/environments/${{ inputs.environment }}
        run: |
          echo "üìä Deploying Data Services..."
          terraform init -reconfigure -backend-config="bucket=eks-learning-lab-terraform-state-${{ secrets.AWS_ACCOUNT_ID }}" -backend-config="key=eks-platform/${{ inputs.environment }}/terraform.tfstate" -backend-config="region=us-east-1"
          terraform plan -out=tfplan -target=module.data_services
          terraform apply -auto-approve tfplan
          
          # Get cluster name and verify
          cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          if [[ -n "$cluster_name" ]]; then
            aws eks update-kubeconfig --name "$cluster_name" --region ${{ secrets.AWS_REGION }}
            sleep 120
            kubectl wait --for=condition=ready --timeout=600s pod -l app=postgresql -n data-services || true
          fi
          echo "‚úÖ Data Services deployed!"

      - name: üìã Generate Deployment Summary
        run: |
          echo "## üöÄ Working Multi-Workflow Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflows Requested**: ${{ inputs.workflows_to_deploy }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Results:**" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.validate.outputs.deploy-1 }}" == "true" ]]; then
            echo "- üèóÔ∏è **Foundation Platform**: ‚úÖ Deployed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üèóÔ∏è **Foundation Platform**: ‚è≠Ô∏è Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.validate.outputs.deploy-2 }}" == "true" ]]; then
            echo "- üåê **Ingress + API Gateway**: ‚úÖ Deployed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üåê **Ingress + API Gateway**: ‚è≠Ô∏è Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.validate.outputs.deploy-3 }}" == "true" ]]; then
            echo "- üìà **LGTM Observability**: ‚úÖ Deployed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üìà **LGTM Observability**: ‚è≠Ô∏è Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.validate.outputs.deploy-4 }}" == "true" ]]; then
            echo "- üîÑ **GitOps & Deployment**: ‚úÖ Deployed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üîÑ **GitOps & Deployment**: ‚è≠Ô∏è Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.validate.outputs.deploy-5 }}" == "true" ]]; then
            echo "- üîê **Security Foundation**: ‚úÖ Deployed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üîê **Security Foundation**: ‚è≠Ô∏è Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.validate.outputs.deploy-6 }}" == "true" ]]; then
            echo "- üõ°Ô∏è **Service Mesh**: ‚úÖ Deployed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üõ°Ô∏è **Service Mesh**: ‚è≠Ô∏è Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.validate.outputs.deploy-7 }}" == "true" ]]; then
            echo "- üìä **Data Services**: ‚úÖ Deployed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üìä **Data Services**: ‚è≠Ô∏è Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **All requested workflows completed successfully!**" >> $GITHUB_STEP_SUMMARY