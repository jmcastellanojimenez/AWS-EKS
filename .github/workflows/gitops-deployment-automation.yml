name: ðŸ”„ GitOps & Deployment Automation

# MANUAL EXECUTION ONLY - No automatic triggers on push/PR
on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Infrastructure Action'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply  
        - destroy
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      confirm_destroy:
        description: 'For DESTROY: type CONFIRM-DESTROY'
        required: false
        type: string
      auto_approve:
        description: 'Auto-approve apply (use with caution)'
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  contents: read

env:
  TF_VERSION: '1.6.0'
  AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}

jobs:
  validate-inputs:
    name: ðŸ” Validate Inputs
    runs-on: ubuntu-latest
    outputs:
      action: ${{ steps.validate.outputs.action }}
      environment: ${{ steps.validate.outputs.environment }}
      should-proceed: ${{ steps.validate.outputs.should-proceed }}
    steps:
      - name: Validate Inputs
        id: validate
        run: |
          echo "action=${{ inputs.action }}" >> $GITHUB_OUTPUT
          echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          
          # Validate destroy confirmation
          if [[ "${{ inputs.action }}" == "destroy" ]]; then
            if [[ "${{ inputs.confirm_destroy }}" != "CONFIRM-DESTROY" ]]; then
              echo "âŒ Destroy action requires 'CONFIRM-DESTROY' confirmation"
              echo "should-proceed=false" >> $GITHUB_OUTPUT
              exit 1
            fi
            echo "âœ… Destroy confirmation validated"
          fi
          
          echo "should-proceed=true" >> $GITHUB_OUTPUT

  check-prerequisites:
    name: ðŸ” Check Prerequisites
    runs-on: ubuntu-latest
    needs: validate-inputs
    if: needs.validate-inputs.outputs.should-proceed == 'true'
    outputs:
      foundation-ready: ${{ steps.check.outputs.foundation-ready }}
      ingress-ready: ${{ steps.check.outputs.ingress-ready }}
      observability-ready: ${{ steps.check.outputs.observability-ready }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-CheckPrerequisites

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸ” Check Prerequisites
        id: check
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          terraform init -backend-config="bucket=eks-learning-lab-terraform-state-${{ secrets.AWS_ACCOUNT_ID }}"
          
          # Check Foundation Platform (Required)
          if terraform state list | grep -q "module.eks.aws_eks_cluster"; then
            cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
            if [[ -n "$cluster_name" ]]; then
              echo "âœ… Foundation Platform found: $cluster_name"
              echo "foundation-ready=true" >> $GITHUB_OUTPUT
            else
              echo "âŒ Foundation Platform cluster name not found"
              echo "foundation-ready=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "âŒ Foundation Platform not deployed. Deploy Workflow 1 first."
            echo "foundation-ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check Ingress Stack (Recommended)
          if terraform state list | grep -q "module.ambassador"; then
            echo "âœ… Ingress + API Gateway Stack found"
            echo "ingress-ready=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  Ingress + API Gateway Stack not found. GitOps will work without it."
            echo "ingress-ready=false" >> $GITHUB_OUTPUT
          fi
          
          # Check Observability Stack (Recommended)
          if terraform state list | grep -q "module.lgtm_observability"; then
            echo "âœ… LGTM Observability Stack found"
            echo "observability-ready=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  LGTM Observability Stack not found. GitOps will work without it."
            echo "observability-ready=false" >> $GITHUB_OUTPUT
          fi

  terraform-operation:
    name: ðŸ”„ Deploy GitOps & Deployment Automation
    runs-on: ubuntu-latest
    needs: [validate-inputs, check-prerequisites]
    if: needs.validate-inputs.outputs.should-proceed == 'true' && needs.check-prerequisites.outputs.foundation-ready == 'true'
    environment: ${{ needs.validate-inputs.outputs.environment }}
    outputs:
      gitops-ready: ${{ steps.output.outputs.gitops-ready }}
      argocd-endpoint: ${{ steps.output.outputs.argocd-endpoint }}
      tekton-ready: ${{ steps.output.outputs.tekton-ready }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-GitOpsStack

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸ“‹ Terraform Init
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          terraform init -backend-config="bucket=eks-learning-lab-terraform-state-${{ secrets.AWS_ACCOUNT_ID }}"

      - name: âœ… Terraform Validate
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: terraform validate

      - name: ðŸ“Š Terraform Plan (Helm Charts First)
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          if [[ "${{ needs.validate-inputs.outputs.action }}" == "destroy" ]]; then
            terraform plan -destroy -out=tfplan -target=module.gitops
          else
            echo "ðŸ”„ Planning Helm charts installation first..."
            terraform plan -out=tfplan-helm \
              -target=module.gitops.kubernetes_namespace.gitops \
              -target=module.gitops.helm_release.argocd \
              -target=module.gitops.helm_release.tekton_pipelines \
              -target=module.gitops.helm_release.tekton_triggers
          fi

      - name: ðŸ“Š Terraform Plan (Full GitOps)
        if: needs.validate-inputs.outputs.action != 'destroy'
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        continue-on-error: true
        run: |
          echo "ðŸ”„ Planning full GitOps deployment..."
          echo "âš ï¸ Note: CRD errors are expected and will be resolved during staged deployment"
          terraform plan -out=tfplan-full -target=module.gitops || true

      - name: ðŸš€ Terraform Apply (Staged Deployment)
        if: needs.validate-inputs.outputs.action == 'apply'
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          if [[ "${{ inputs.auto_approve }}" == "true" ]]; then
            echo "ðŸš€ Stage 1: Deploying Helm charts to install CRDs..."
            terraform apply -auto-approve tfplan-helm
            
            echo "â³ Waiting for CRDs to be established..."
            # Configure kubectl first
            cluster_name=$(terraform output -raw cluster_name)
            aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name "$cluster_name"
            
            # Wait for ArgoCD CRDs
            echo "ðŸ”„ Waiting for ArgoCD CRDs..."
            timeout 300 bash -c '
              while ! kubectl get crd applications.argoproj.io >/dev/null 2>&1; do
                echo "Waiting for ArgoCD Application CRD..."
                sleep 10
              done
              while ! kubectl get crd applicationsets.argoproj.io >/dev/null 2>&1; do
                echo "Waiting for ArgoCD ApplicationSet CRD..."
                sleep 10
              done
            '
            
            # Wait for Tekton CRDs
            echo "ðŸ—ï¸ Waiting for Tekton CRDs..."
            timeout 300 bash -c '
              while ! kubectl get crd pipelines.tekton.dev >/dev/null 2>&1; do
                echo "Waiting for Tekton Pipeline CRD..."
                sleep 10
              done
              while ! kubectl get crd tasks.tekton.dev >/dev/null 2>&1; do
                echo "Waiting for Tekton Task CRD..."
                sleep 10
              done
              while ! kubectl get crd eventlisteners.triggers.tekton.dev >/dev/null 2>&1; do
                echo "Waiting for Tekton EventListener CRD..."
                sleep 10
              done
            '
            
            echo "âœ… All CRDs are now available!"
            
            echo "ðŸš€ Stage 2: Deploying full GitOps stack..."
            echo "ðŸ“‹ Re-planning with CRDs now available..."
            terraform plan -out=tfplan-full-stage2 -target=module.gitops
            terraform apply -auto-approve tfplan-full-stage2
            
            echo "âœ… GitOps deployment completed successfully!"
          else
            echo "âŒ Manual approval required. Set auto_approve=true to proceed."
            exit 1
          fi

      - name: ðŸ—‘ï¸ Terraform Destroy
        if: needs.validate-inputs.outputs.action == 'destroy'
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        timeout-minutes: 45
        run: terraform apply tfplan

      - name: ðŸ“¤ Get GitOps Information
        id: output
        if: needs.validate-inputs.outputs.action == 'apply'
        working-directory: terraform/environments/${{ needs.validate-inputs.outputs.environment }}
        run: |
          # Get GitOps stack information
          gitops_ready=$(terraform output -raw gitops_ready 2>/dev/null || echo "false")
          argocd_endpoint=$(terraform output -raw argocd_endpoint 2>/dev/null || echo "")
          tekton_ready=$(terraform output -raw tekton_ready 2>/dev/null || echo "false")
          
          echo "gitops-ready=$gitops_ready" >> $GITHUB_OUTPUT
          echo "argocd-endpoint=$argocd_endpoint" >> $GITHUB_OUTPUT
          echo "tekton-ready=$tekton_ready" >> $GITHUB_OUTPUT
          
          echo "âœ… GitOps & Deployment Automation deployed successfully!"
          echo "ðŸ”„ ArgoCD: $argocd_endpoint"
          echo "ðŸ—ï¸ Tekton: $tekton_ready"

      - name: ðŸ”§ Configure kubectl and Verify Stack
        if: needs.validate-inputs.outputs.action == 'apply'
        run: |
          cluster_name=$(cd terraform/environments/${{ needs.validate-inputs.outputs.environment }} && terraform output -raw cluster_name)
          if [[ -n "$cluster_name" ]]; then
            # kubectl already configured in the apply step
            echo "ðŸ” Verifying GitOps & Deployment Automation Stack..."
            
            # Wait a bit for pods to start
            sleep 30
            
            # Check GitOps namespace
            echo "ðŸ”„ Checking GitOps namespace..."
            kubectl get namespace gitops
            kubectl get pods -n gitops
            kubectl get svc -n gitops
            
            # Check ArgoCD components
            echo "ðŸ”„ Checking ArgoCD components..."
            kubectl get deployments -n gitops -l app.kubernetes.io/part-of=argocd
            kubectl get pods -n gitops -l app.kubernetes.io/part-of=argocd
            
            # Check Tekton components
            echo "ðŸ—ï¸ Checking Tekton components..."
            kubectl get deployments -n gitops -l app.kubernetes.io/part-of=tekton-pipelines
            kubectl get pods -n gitops -l app.kubernetes.io/part-of=tekton-pipelines
            
            # Check CRDs are available
            echo "ðŸ“‹ Checking CRDs..."
            kubectl get crd | grep -E "(argoproj|tekton)" | head -5
            
            # Check GitOps service accounts
            echo "ðŸ” Checking GitOps service accounts..."
            kubectl get serviceaccounts -n gitops
            
            # Check ArgoCD Applications (may be empty initially)
            echo "ðŸ“¦ Checking ArgoCD Applications..."
            kubectl get applications -n gitops || echo "No applications found yet (this is normal for initial deployment)"
            
            # Check Tekton resources
            echo "ðŸ”§ Checking Tekton resources..."
            kubectl get pipelines -n gitops || echo "No pipelines found yet"
            kubectl get tasks -n gitops || echo "No tasks found yet"
            
            # Get ArgoCD admin password
            echo "ðŸ”‘ Getting ArgoCD admin password..."
            kubectl get secret -n gitops argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d || echo "ArgoCD password not ready yet"
            
            echo "âœ… GitOps stack verification completed!"
            echo "ðŸŽ‰ GitOps & Deployment Automation is ready for use!"
          fi

  summary:
    name: ðŸ“‹ Deployment Summary
    runs-on: ubuntu-latest
    needs: [validate-inputs, check-prerequisites, terraform-operation]
    if: always()
    steps:
      - name: Generate Summary
        run: |
          echo "## ðŸ”„ GitOps & Deployment Automation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Action**: ${{ needs.validate-inputs.outputs.action }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ needs.validate-inputs.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Foundation Check**: ${{ needs.check-prerequisites.outputs.foundation-ready }}" >> $GITHUB_STEP_SUMMARY
          echo "**Ingress Stack**: ${{ needs.check-prerequisites.outputs.ingress-ready }}" >> $GITHUB_STEP_SUMMARY
          echo "**Observability Stack**: ${{ needs.check-prerequisites.outputs.observability-ready }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ needs.terraform-operation.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.check-prerequisites.outputs.foundation-ready }}" != "true" ]]; then
            echo "### âŒ Foundation Platform Required" >> $GITHUB_STEP_SUMMARY
            echo "Deploy **ðŸ—ï¸ Workflow 1: Foundation Platform** first before running this workflow." >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.terraform-operation.result }}" == "success" ]]; then
            if [[ "${{ needs.validate-inputs.outputs.action }}" == "apply" ]]; then
              echo "### âœ… GitOps & Deployment Automation Deployed Successfully!" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Components Deployed:**" >> $GITHUB_STEP_SUMMARY
              echo "- ðŸ”„ **ArgoCD**: GitOps continuous deployment" >> $GITHUB_STEP_SUMMARY
              echo "- ðŸ—ï¸ **Tekton**: Cloud-native CI/CD pipelines" >> $GITHUB_STEP_SUMMARY
              echo "- ðŸ“¦ **Git Repositories**: Application and infrastructure repos" >> $GITHUB_STEP_SUMMARY
              echo "- ðŸ” **RBAC**: Role-based access control for GitOps" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Resource Allocation:**" >> $GITHUB_STEP_SUMMARY
              echo "- ArgoCD Server: ~250m CPU, ~512Mi memory" >> $GITHUB_STEP_SUMMARY
              echo "- ArgoCD Repo Server: ~100m CPU, ~256Mi memory" >> $GITHUB_STEP_SUMMARY
              echo "- ArgoCD Application Controller: ~250m CPU, ~512Mi memory" >> $GITHUB_STEP_SUMMARY
              echo "- Tekton Controller: ~100m CPU, ~256Mi memory" >> $GITHUB_STEP_SUMMARY
              echo "- **Total**: ~700m CPU, ~1.5Gi memory" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Access Instructions:**" >> $GITHUB_STEP_SUMMARY
              echo "1. Get ArgoCD admin password: \\`kubectl get secret -n gitops argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d\\`" >> $GITHUB_STEP_SUMMARY
              echo "2. Port-forward to ArgoCD: \\`kubectl port-forward -n gitops svc/argocd-server 8080:80\\`" >> $GITHUB_STEP_SUMMARY
              echo "3. Access ArgoCD: http://localhost:8080 (admin/\\<password\\>)" >> $GITHUB_STEP_SUMMARY
              echo "4. Configure Git repositories for EcoTrack microservices" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**GitOps Workflow:**" >> $GITHUB_STEP_SUMMARY
              echo "1. **Code Commit** â†’ Git repository" >> $GITHUB_STEP_SUMMARY
              echo "2. **Tekton Pipeline** â†’ Build, test, and create manifests" >> $GITHUB_STEP_SUMMARY
              echo "3. **ArgoCD Sync** â†’ Deploy to Kubernetes automatically" >> $GITHUB_STEP_SUMMARY
              echo "4. **Monitoring** â†’ Observe via LGTM stack (if deployed)" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
              echo "1. Create ArgoCD applications for EcoTrack microservices" >> $GITHUB_STEP_SUMMARY
              echo "2. Set up Tekton pipelines for automated builds" >> $GITHUB_STEP_SUMMARY
              echo "3. Configure Git webhooks for automatic deployments" >> $GITHUB_STEP_SUMMARY
              echo "4. Ready for Workflows 5-7: Security, Service Mesh, Data Services" >> $GITHUB_STEP_SUMMARY
            elif [[ "${{ needs.validate-inputs.outputs.action }}" == "destroy" ]]; then
              echo "### âœ… GitOps Stack Destroyed Successfully!" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ’° ArgoCD and Tekton components have been cleaned up to save costs." >> $GITHUB_STEP_SUMMARY
            elif [[ "${{ needs.validate-inputs.outputs.action }}" == "plan" ]]; then
              echo "### ðŸ“Š Plan Generated Successfully!" >> $GITHUB_STEP_SUMMARY
              echo "Review the plan output above before proceeding with apply." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### âŒ Operation Failed!" >> $GITHUB_STEP_SUMMARY
            echo "Please check the logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Slack Notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#platform-deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}