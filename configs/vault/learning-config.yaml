# HashiCorp Vault Configuration for EKS Learning Lab
# Includes secret management, authentication, and Kubernetes integration

# Service Account for Vault
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-auth
  namespace: vault

---
# ClusterRoleBinding for Vault authentication
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-auth-delegator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: vault-auth
  namespace: vault

---
# Secret for Vault token reviewer
apiVersion: v1
kind: Secret
metadata:
  name: vault-token-reviewer
  namespace: vault
  annotations:
    kubernetes.io/service-account.name: vault-auth
type: kubernetes.io/service-account-token

---
# ConfigMap for Vault initialization and configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-init-script
  namespace: vault
data:
  init-vault.sh: |
    #!/bin/bash
    set -e
    
    # Wait for Vault to be ready
    until vault status 2>/dev/null; do
      echo "Waiting for Vault to be ready..."
      sleep 5
    done
    
    # Check if Vault is initialized
    if ! vault status | grep -q "Initialized.*true"; then
      echo "Vault not initialized, initializing..."
      exit 1
    fi
    
    # Login with root token (dev mode)
    vault auth -method=token token=root-token
    
    # Enable KV secrets engine
    vault secrets enable -path=secret kv-v2 || echo "KV engine already enabled"
    
    # Enable Kubernetes auth method
    vault auth enable kubernetes || echo "Kubernetes auth already enabled"
    
    # Configure Kubernetes auth
    vault write auth/kubernetes/config \
        token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
        kubernetes_host="https://kubernetes.default.svc:443" \
        kubernetes_ca_cert="$(cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt)"
    
    # Create a policy for applications
    vault policy write app-policy - <<EOF
    path "secret/data/app/*" {
      capabilities = ["read", "list"]
    }
    path "secret/metadata/app/*" {
      capabilities = ["read", "list"]
    }
    EOF
    
    # Create a policy for databases
    vault policy write db-policy - <<EOF
    path "secret/data/database/*" {
      capabilities = ["read", "list"]
    }
    path "database/creds/readonly" {
      capabilities = ["read"]
    }
    EOF
    
    # Create Kubernetes auth role for applications
    vault write auth/kubernetes/role/app-role \
        bound_service_account_names=app-service-account \
        bound_service_account_namespaces=default,sample-apps \
        policies=app-policy \
        ttl=24h
    
    # Create Kubernetes auth role for databases
    vault write auth/kubernetes/role/db-role \
        bound_service_account_names=db-service-account \
        bound_service_account_namespaces=default \
        policies=db-policy \
        ttl=1h
    
    # Store some sample secrets
    vault kv put secret/app/config \
        database_url="postgresql://user:pass@db:5432/myapp" \
        api_key="sample-api-key-12345" \
        debug_mode="true"
    
    vault kv put secret/app/credentials \
        username="appuser" \
        password="secure-password-123"
    
    vault kv put secret/database/config \
        host="postgres.default.svc.cluster.local" \
        port="5432" \
        database="learning_lab" \
        ssl_mode="require"
    
    # Enable database secrets engine for dynamic credentials
    vault secrets enable database || echo "Database engine already enabled"
    
    # Configure PostgreSQL connection (example)
    vault write database/config/postgresql \
        plugin_name=postgresql-database-plugin \
        connection_url="postgresql://{{username}}:{{password}}@postgres.default.svc.cluster.local:5432/learning_lab?sslmode=disable" \
        allowed_roles="readonly,readwrite" \
        username="vault" \
        password="vault-password"
    
    # Create database role for readonly access
    vault write database/roles/readonly \
        db_name=postgresql \
        creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
        default_ttl="1h" \
        max_ttl="24h"
    
    # Enable transit secrets engine for encryption
    vault secrets enable transit || echo "Transit engine already enabled"
    
    # Create encryption key
    vault write -f transit/keys/app-encryption
    
    # Create policy for transit encryption
    vault policy write transit-policy - <<EOF
    path "transit/encrypt/app-encryption" {
      capabilities = [ "update" ]
    }
    path "transit/decrypt/app-encryption" {
      capabilities = [ "update" ]
    }
    EOF
    
    echo "Vault configuration completed successfully!"

---
# Job to initialize Vault configuration
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init-config
  namespace: vault
spec:
  template:
    spec:
      serviceAccountName: vault-auth
      containers:
      - name: vault-init
        image: vault:1.15.2
        env:
        - name: VAULT_ADDR
          value: "http://vault:8200"
        - name: VAULT_TOKEN
          value: "root-token"
        command: ["/bin/sh"]
        args: ["/scripts/init-vault.sh"]
        volumeMounts:
        - name: init-script
          mountPath: /scripts
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
      volumes:
      - name: init-script
        configMap:
          name: vault-init-script
          defaultMode: 0755
      restartPolicy: OnFailure
  backoffLimit: 3

---
# Service Account for applications using Vault
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-service-account
  namespace: default

---
# Service Account for database access
apiVersion: v1
kind: ServiceAccount
metadata:
  name: db-service-account
  namespace: default

---
# Sample application that uses Vault secrets
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vault-demo-app
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vault-demo-app
  template:
    metadata:
      labels:
        app: vault-demo-app
      annotations:
        vault.hashicorp.com/agent-inject: "true"
        vault.hashicorp.com/role: "app-role"
        vault.hashicorp.com/agent-inject-secret-config: "secret/data/app/config"
        vault.hashicorp.com/agent-inject-template-config: |
          {{- with secret "secret/data/app/config" -}}
          export DATABASE_URL="{{ .Data.data.database_url }}"
          export API_KEY="{{ .Data.data.api_key }}"
          export DEBUG_MODE="{{ .Data.data.debug_mode }}"
          {{- end }}
        vault.hashicorp.com/agent-inject-secret-credentials: "secret/data/app/credentials"
        vault.hashicorp.com/agent-inject-template-credentials: |
          {{- with secret "secret/data/app/credentials" -}}
          export USERNAME="{{ .Data.data.username }}"
          export PASSWORD="{{ .Data.data.password }}"
          {{- end }}
    spec:
      serviceAccountName: app-service-account
      containers:
      - name: app
        image: nginx:alpine
        ports:
        - containerPort: 80
        command: ["/bin/sh"]
        args:
        - -c
        - |
          # Source Vault secrets
          [ -f /vault/secrets/config ] && source /vault/secrets/config
          [ -f /vault/secrets/credentials ] && source /vault/secrets/credentials
          
          # Create a simple HTML page showing the configuration
          cat > /usr/share/nginx/html/index.html << EOF
          <!DOCTYPE html>
          <html>
          <head>
              <title>Vault Demo App</title>
              <style>
                  body { font-family: Arial, sans-serif; margin: 40px; }
                  .secret { background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px; }
                  .warning { color: red; font-weight: bold; }
              </style>
          </head>
          <body>
              <h1>Vault Integration Demo</h1>
              <p>This application demonstrates HashiCorp Vault integration with Kubernetes.</p>
              
              <h2>Configuration (from Vault)</h2>
              <div class="secret">
                  <strong>Database URL:</strong> \${DATABASE_URL:-Not loaded}<br>
                  <strong>API Key:</strong> \${API_KEY:-Not loaded}<br>
                  <strong>Debug Mode:</strong> \${DEBUG_MODE:-Not loaded}
              </div>
              
              <h2>Credentials (from Vault)</h2>
              <div class="secret">
                  <strong>Username:</strong> \${USERNAME:-Not loaded}<br>
                  <strong>Password:</strong> <span class="warning">[REDACTED]</span>
              </div>
              
              <h2>Vault Secrets Files</h2>
              <pre>$(ls -la /vault/secrets/ 2>/dev/null || echo "Secrets not mounted")</pre>
              
              <h2>Learning Resources</h2>
              <ul>
                  <li><a href="https://learn.hashicorp.com/vault">Vault Learning Path</a></li>
                  <li><a href="https://www.vaultproject.io/docs/platform/k8s">Vault on Kubernetes</a></li>
                  <li><a href="https://www.vaultproject.io/docs/auth/kubernetes">Kubernetes Auth Method</a></li>
              </ul>
          </body>
          </html>
          EOF
          
          # Start nginx
          nginx -g 'daemon off;'
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi

---
# Service for the demo app
apiVersion: v1
kind: Service
metadata:
  name: vault-demo-app
  namespace: default
spec:
  selector:
    app: vault-demo-app
  ports:
  - port: 80
    targetPort: 80

---
# ConfigMap with Vault CLI examples
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-examples
  namespace: vault
data:
  vault-commands.sh: |
    #!/bin/bash
    # Vault CLI Examples for EKS Learning Lab
    
    # Set Vault address
    export VAULT_ADDR=http://vault:8200
    
    # Login with root token (dev mode only)
    vault auth -method=token token=root-token
    
    # Basic KV operations
    echo "=== Key-Value Operations ==="
    vault kv put secret/myapp/config database_url=postgresql://localhost/db
    vault kv get secret/myapp/config
    vault kv get -field=database_url secret/myapp/config
    vault kv delete secret/myapp/config
    
    # List secrets
    vault kv list secret/
    
    # Kubernetes authentication
    echo "=== Kubernetes Auth ==="
    vault write auth/kubernetes/role/demo \
        bound_service_account_names=default \
        bound_service_account_namespaces=default \
        policies=default \
        ttl=24h
    
    # Dynamic database credentials
    echo "=== Dynamic Database Credentials ==="
    vault read database/creds/readonly
    
    # Transit encryption
    echo "=== Encryption as a Service ==="
    vault write transit/encrypt/app-encryption plaintext=$(base64 <<< "my secret data")
    vault write transit/decrypt/app-encryption ciphertext=vault:v1:...
    
    # Policies
    echo "=== Policies ==="
    vault policy list
    vault policy read app-policy
    
    # Check Vault status
    vault status
    vault auth -methods
    vault secrets list

  vault-exercises.md: |
    # Vault Learning Exercises
    
    ## Exercise 1: Basic Secret Management
    1. Store a database password in Vault
    2. Retrieve the password using the CLI
    3. Update the password and verify the change
    
    ## Exercise 2: Kubernetes Integration
    1. Create a service account for your application
    2. Configure Vault authentication for the service account
    3. Deploy an application that retrieves secrets from Vault
    
    ## Exercise 3: Dynamic Secrets
    1. Configure a database connection in Vault
    2. Create a role for database access
    3. Generate dynamic database credentials
    4. Test the credentials and observe expiration
    
    ## Exercise 4: Encryption as a Service
    1. Create an encryption key in the transit engine
    2. Encrypt sensitive data using the API
    3. Decrypt the data and verify the result
    
    ## Exercise 5: Policy Management
    1. Create a custom policy for your application
    2. Test the policy by attempting various operations
    3. Refine the policy based on least-privilege principles
    
    ## Troubleshooting Commands
    ```bash
    # Check Vault status
    vault status
    
    # List authentication methods
    vault auth -methods
    
    # List secrets engines
    vault secrets list
    
    # Check token capabilities
    vault token capabilities secret/data/app/config
    
    # Audit policy permissions
    vault policy read app-policy
    ```