apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: container-build
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/version: "0.1"
    app.kubernetes.io/part-of: gitops-platform
  annotations:
    tekton.dev/pipelines.minVersion: "0.17.0"
    tekton.dev/categories: Image Build
    tekton.dev/tags: image, docker, buildkit, kaniko
    tekton.dev/displayName: "Container Build Task"
    tekton.dev/platforms: "linux/amd64,linux/arm64"
spec:
  description: >-
    This task builds container images using Kaniko for secure, 
    rootless container builds with multi-architecture support.

  params:
    - name: IMAGE_NAME
      description: Name (reference) of the image to build
      type: string
    - name: IMAGE_TAG
      description: Tag for the image
      type: string
      default: "latest"
    - name: DOCKERFILE
      description: Path to the Dockerfile to build
      type: string
      default: "./Dockerfile"
    - name: CONTEXT
      description: Path to the build context
      type: string
      default: "."
    - name: BUILD_ARGS
      description: Build arguments for the Docker build
      type: array
      default: []
    - name: REGISTRY_URL
      description: Container registry URL
      type: string
    - name: PLATFORMS
      description: Target platforms for multi-arch builds
      type: string
      default: "linux/amd64"
    - name: CACHE_ENABLED
      description: Enable build cache
      type: string
      default: "true"
    - name: CACHE_REPO
      description: Cache repository for layer caching
      type: string
      default: ""
    - name: PUSH_IMAGE
      description: Whether to push the image to registry
      type: string
      default: "true"

  workspaces:
    - name: source
      description: Workspace containing the source code and Dockerfile
    - name: dockerconfig
      description: Docker registry credentials
      optional: true

  results:
    - name: IMAGE_DIGEST
      description: Digest of the image just built
    - name: IMAGE_URL
      description: URL of the image with digest

  steps:
    - name: validate-dockerfile
      image: alpine:3.18
      workingDir: $(workspaces.source.path)
      script: |
        #!/bin/sh
        set -e
        
        echo "üîç Validating Dockerfile..."
        
        if [ ! -f "$(params.DOCKERFILE)" ]; then
          echo "‚ùå Error: Dockerfile not found at $(params.DOCKERFILE)"
          exit 1
        fi
        
        echo "‚úÖ Dockerfile found at $(params.DOCKERFILE)"
        
        # Check for basic Dockerfile structure
        if ! grep -q "^FROM" "$(params.DOCKERFILE)"; then
          echo "‚ùå Error: Invalid Dockerfile - missing FROM instruction"
          exit 1
        fi
        
        echo "‚úÖ Dockerfile validation passed"

    - name: prepare-build
      image: alpine:3.18
      workingDir: $(workspaces.source.path)
      script: |
        #!/bin/sh
        set -e
        
        echo "üîß Preparing container build..."
        
        # Create full image reference
        FULL_IMAGE_NAME="$(params.REGISTRY_URL)/$(params.IMAGE_NAME):$(params.IMAGE_TAG)"
        echo "üì¶ Building image: $FULL_IMAGE_NAME"
        
        # Display build context info
        echo "üìÅ Build context: $(params.CONTEXT)"
        echo "üìÑ Dockerfile: $(params.DOCKERFILE)"
        echo "üèóÔ∏è Platforms: $(params.PLATFORMS)"
        
        # List build context contents
        echo "üìã Build context contents:"
        find "$(params.CONTEXT)" -maxdepth 2 -type f | head -20
        
        echo "‚úÖ Build preparation complete"

    - name: build-and-push
      image: gcr.io/kaniko-project/executor:v1.19.0
      workingDir: $(workspaces.source.path)
      env:
        - name: DOCKER_CONFIG
          value: $(workspaces.dockerconfig.path)
      args:
        - --dockerfile=$(params.DOCKERFILE)
        - --context=$(params.CONTEXT)
        - --destination=$(params.REGISTRY_URL)/$(params.IMAGE_NAME):$(params.IMAGE_TAG)
        - --cache=$(params.CACHE_ENABLED)
        - --cache-repo=$(params.CACHE_REPO)
        - --skip-tls-verify=false
        - --reproducible
        - --cleanup
        - --log-format=text
        - --verbosity=info
      script: |
        #!/busybox/sh
        set -e
        
        echo "üèóÔ∏è Starting container build with Kaniko..."
        
        # Build additional arguments
        BUILD_ARGS=""
        for arg in $(params.BUILD_ARGS[*]); do
          BUILD_ARGS="$BUILD_ARGS --build-arg $arg"
        done
        
        # Construct kaniko command
        KANIKO_CMD="/kaniko/executor"
        KANIKO_CMD="$KANIKO_CMD --dockerfile=$(params.DOCKERFILE)"
        KANIKO_CMD="$KANIKO_CMD --context=$(params.CONTEXT)"
        KANIKO_CMD="$KANIKO_CMD --destination=$(params.REGISTRY_URL)/$(params.IMAGE_NAME):$(params.IMAGE_TAG)"
        
        # Add cache settings if enabled
        if [ "$(params.CACHE_ENABLED)" = "true" ]; then
          KANIKO_CMD="$KANIKO_CMD --cache=true"
          if [ -n "$(params.CACHE_REPO)" ]; then
            KANIKO_CMD="$KANIKO_CMD --cache-repo=$(params.CACHE_REPO)"
          fi
        fi
        
        # Add build args
        KANIKO_CMD="$KANIKO_CMD $BUILD_ARGS"
        
        # Additional kaniko flags
        KANIKO_CMD="$KANIKO_CMD --skip-tls-verify=false"
        KANIKO_CMD="$KANIKO_CMD --reproducible"
        KANIKO_CMD="$KANIKO_CMD --cleanup"
        KANIKO_CMD="$KANIKO_CMD --log-format=text"
        KANIKO_CMD="$KANIKO_CMD --verbosity=info"
        
        # Only push if enabled
        if [ "$(params.PUSH_IMAGE)" != "true" ]; then
          KANIKO_CMD="$KANIKO_CMD --no-push"
          echo "‚ÑπÔ∏è Image will not be pushed to registry"
        fi
        
        echo "üöÄ Executing: $KANIKO_CMD"
        exec $KANIKO_CMD

    - name: extract-digest
      image: alpine:3.18
      workingDir: $(workspaces.source.path)
      script: |
        #!/bin/sh
        set -e
        
        echo "üîç Extracting image digest..."
        
        # The digest is typically written to /kaniko/digest-file by kaniko
        if [ -f "/kaniko/digest-file" ]; then
          DIGEST=$(cat /kaniko/digest-file)
          echo "üìã Image digest: $DIGEST"
          echo -n "$DIGEST" > $(results.IMAGE_DIGEST.path)
          
          # Create full image URL with digest
          IMAGE_URL="$(params.REGISTRY_URL)/$(params.IMAGE_NAME)@$DIGEST"
          echo "üîó Image URL: $IMAGE_URL"
          echo -n "$IMAGE_URL" > $(results.IMAGE_URL.path)
        else
          echo "‚ö†Ô∏è Warning: Digest file not found, using tag-based reference"
          IMAGE_URL="$(params.REGISTRY_URL)/$(params.IMAGE_NAME):$(params.IMAGE_TAG)"
          echo -n "unknown" > $(results.IMAGE_DIGEST.path)
          echo -n "$IMAGE_URL" > $(results.IMAGE_URL.path)
        fi
        
        echo "‚úÖ Image build completed successfully"

    - name: scan-image
      image: aquasec/trivy:0.49.1
      workingDir: $(workspaces.source.path)
      script: |
        #!/bin/sh
        set -e
        
        echo "üîç Scanning image for vulnerabilities..."
        
        IMAGE_URL="$(cat $(results.IMAGE_URL.path))"
        
        # Perform security scan
        trivy image \
          --format table \
          --severity HIGH,CRITICAL \
          --no-progress \
          --timeout 10m \
          "$IMAGE_URL" || true
        
        echo "‚úÖ Image scan completed"

    - name: build-summary
      image: alpine:3.18
      workingDir: $(workspaces.source.path)
      script: |
        #!/bin/sh
        set -e
        
        echo "üìã Container Build Summary"
        echo "========================="
        echo "Image Name: $(params.IMAGE_NAME)"
        echo "Image Tag: $(params.IMAGE_TAG)"
        echo "Registry: $(params.REGISTRY_URL)"
        echo "Dockerfile: $(params.DOCKERFILE)"
        echo "Build Context: $(params.CONTEXT)"
        echo "Platforms: $(params.PLATFORMS)"
        echo "Cache Enabled: $(params.CACHE_ENABLED)"
        
        if [ -f "$(results.IMAGE_DIGEST.path)" ]; then
          echo "Image Digest: $(cat $(results.IMAGE_DIGEST.path))"
        fi
        
        if [ -f "$(results.IMAGE_URL.path)" ]; then
          echo "Image URL: $(cat $(results.IMAGE_URL.path))"
        fi
        
        echo ""
        echo "‚úÖ Container build completed successfully!"

  securityContext:
    runAsUser: 0
    runAsGroup: 0