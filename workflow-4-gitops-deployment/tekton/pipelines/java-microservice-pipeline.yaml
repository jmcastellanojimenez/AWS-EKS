apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: java-microservice-pipeline
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/name: java-microservice-pipeline
    app.kubernetes.io/part-of: gitops-platform
    app.kubernetes.io/version: "1.0"
  annotations:
    tekton.dev/pipelines.minVersion: "0.17.0"
    tekton.dev/categories: CI/CD
    tekton.dev/tags: java, maven, docker, gitops, ecotrack
    tekton.dev/displayName: "EcoTrack Java Microservice CI/CD Pipeline"
    tekton.dev/platforms: "linux/amd64,linux/arm64"
spec:
  description: >-
    Complete CI/CD pipeline for EcoTrack Java microservices.
    Builds, tests, scans, containerizes, and deploys via GitOps with 
    full observability integration.

  params:
    # Source repository parameters
    - name: SOURCE_REPO_URL
      description: Git repository URL for source code
      type: string
    - name: SOURCE_REVISION
      description: Git revision to build (branch, tag, or commit SHA)
      type: string
      default: "main"
    - name: SOURCE_BRANCH
      description: Git branch being built
      type: string
      default: "main"
    - name: SOURCE_SUBPATH
      description: Subpath within the repository
      type: string
      default: "."

    # Service parameters
    - name: SERVICE_NAME
      description: Name of the microservice
      type: string
    - name: ENVIRONMENT
      description: Target environment (dev, staging, prod)
      type: string
      default: "dev"

    # Build parameters
    - name: JAVA_VERSION
      description: Java version for build (11, 17, 21)
      type: string
      default: "17"
    - name: MAVEN_GOALS
      description: Maven goals to execute
      type: string
      default: "clean package"
    - name: MAVEN_ARGS
      description: Additional Maven arguments
      type: string
      default: "-B -DskipTests=false"
    - name: ENABLE_NATIVE_BUILD
      description: Enable GraalVM native image compilation
      type: string
      default: "false"
    - name: RUN_TESTS
      description: Whether to run tests during build
      type: string
      default: "true"

    # Container image parameters
    - name: CONTAINER_REGISTRY
      description: Container registry URL
      type: string
    - name: IMAGE_NAME
      description: Container image name
      type: string
    - name: IMAGE_TAG
      description: Container image tag
      type: string
      default: "latest"
    - name: DOCKERFILE_PATH
      description: Path to Dockerfile
      type: string
      default: "./Dockerfile"

    # Security scanning parameters
    - name: SECURITY_SCAN_ENABLED
      description: Enable security scanning
      type: string
      default: "true"
    - name: SECURITY_SCAN_SEVERITY
      description: Security scan severity levels
      type: string
      default: "HIGH,CRITICAL"
    - name: FAIL_ON_SECURITY_ISSUES
      description: Fail pipeline on security issues
      type: string
      default: "false"

    # GitOps parameters
    - name: GITOPS_REPO_URL
      description: Git repository URL for GitOps manifests
      type: string
    - name: GITOPS_BRANCH
      description: Branch in GitOps repository
      type: string
      default: "main"
    - name: AUTO_DEPLOY
      description: Automatically deploy after successful build
      type: string
      default: "true"
    - name: CREATE_PR
      description: Create pull request for GitOps changes
      type: string
      default: "false"

  workspaces:
    - name: source-workspace
      description: Workspace for source code
    - name: cache-workspace
      description: Workspace for build cache
    - name: gitops-workspace
      description: Workspace for GitOps repository

  results:
    - name: IMAGE_URL
      description: URL of the built container image
      value: $(tasks.build-container.results.IMAGE_URL)
    - name: IMAGE_DIGEST
      description: Digest of the built container image
      value: $(tasks.build-container.results.IMAGE_DIGEST)
    - name: GITOPS_COMMIT_SHA
      description: SHA of the GitOps commit
      value: $(tasks.update-gitops-manifests.results.COMMIT_SHA)

  tasks:
    # 1. Clone source repository
    - name: clone-source
      taskRef:
        name: git-clone
        kind: ClusterTask
      params:
        - name: url
          value: $(params.SOURCE_REPO_URL)
        - name: revision
          value: $(params.SOURCE_REVISION)
        - name: subPath
          value: $(params.SOURCE_SUBPATH)
        - name: deleteExisting
          value: "true"
        - name: verbose
          value: "true"
      workspaces:
        - name: output
          workspace: source-workspace

    # 2. Build application with Maven
    - name: build-application
      taskRef:
        name: maven-build
      runAfter: ["clone-source"]
      params:
        - name: JAVA_VERSION
          value: $(params.JAVA_VERSION)
        - name: MAVEN_GOALS
          value: $(params.MAVEN_GOALS)
        - name: MAVEN_ARGS
          value: $(params.MAVEN_ARGS)
        - name: CONTEXT_DIR
          value: $(params.SOURCE_SUBPATH)
        - name: ENABLE_NATIVE_BUILD
          value: $(params.ENABLE_NATIVE_BUILD)
      workspaces:
        - name: source
          workspace: source-workspace
        - name: maven-cache
          workspace: cache-workspace

    # 3. Run unit tests (if not skipped in Maven build)
    - name: run-unit-tests
      taskRef:
        name: maven
        kind: ClusterTask
      runAfter: ["build-application"]
      when:
        - input: "$(params.RUN_TESTS)"
          operator: in
          values: ["true", "True", "TRUE"]
      params:
        - name: GOALS
          value: ["test", "jacoco:report"]
        - name: MAVEN_IMAGE
          value: "eclipse-temurin:$(params.JAVA_VERSION)-jdk"
      workspaces:
        - name: source
          workspace: source-workspace
        - name: maven-settings
          workspace: cache-workspace

    # 4. Analyze code quality (SonarQube integration)
    - name: code-quality-analysis
      taskRef:
        name: sonarqube-scanner
        kind: ClusterTask
      runAfter: ["run-unit-tests"]
      when:
        - input: "$(params.RUN_TESTS)"
          operator: in
          values: ["true", "True", "TRUE"]
      params:
        - name: SONAR_HOST_URL
          value: "${SONARQUBE_URL}"
        - name: SONAR_PROJECT_KEY
          value: "ecotrack-$(params.SERVICE_NAME)"
      workspaces:
        - name: source
          workspace: source-workspace

    # 5. Build container image
    - name: build-container
      taskRef:
        name: container-build
      runAfter: ["build-application"]
      params:
        - name: IMAGE_NAME
          value: $(params.IMAGE_NAME)
        - name: IMAGE_TAG
          value: $(params.IMAGE_TAG)
        - name: DOCKERFILE
          value: $(params.DOCKERFILE_PATH)
        - name: CONTEXT
          value: $(params.SOURCE_SUBPATH)
        - name: REGISTRY_URL
          value: $(params.CONTAINER_REGISTRY)
        - name: PLATFORMS
          value: "linux/amd64"
        - name: CACHE_ENABLED
          value: "true"
        - name: PUSH_IMAGE
          value: "true"
      workspaces:
        - name: source
          workspace: source-workspace
        - name: dockerconfig
          workspace: cache-workspace

    # 6. Security scanning
    - name: security-scan
      taskRef:
        name: security-scan
      runAfter: ["build-container"]
      when:
        - input: "$(params.SECURITY_SCAN_ENABLED)"
          operator: in
          values: ["true", "True", "TRUE"]
      params:
        - name: IMAGE
          value: $(tasks.build-container.results.IMAGE_URL)
        - name: SCAN_TYPE
          value: "image"
        - name: FORMAT
          value: "table"
        - name: SEVERITY
          value: $(params.SECURITY_SCAN_SEVERITY)
        - name: EXIT_CODE
          value: "$(params.FAIL_ON_SECURITY_ISSUES)"
        - name: SECRET_SCAN
          value: "true"
        - name: CONFIG_SCAN
          value: "false"
      workspaces:
        - name: source
          workspace: source-workspace

    # 7. Update GitOps manifests
    - name: update-gitops-manifests
      taskRef:
        name: gitops-update
      runAfter: ["security-scan"]
      when:
        - input: "$(params.AUTO_DEPLOY)"
          operator: in
          values: ["true", "True", "TRUE"]
      params:
        - name: GIT_REPOSITORY
          value: $(params.GITOPS_REPO_URL)
        - name: GIT_BRANCH
          value: $(params.GITOPS_BRANCH)
        - name: SERVICE_NAME
          value: $(params.SERVICE_NAME)
        - name: ENVIRONMENT
          value: $(params.ENVIRONMENT)
        - name: NEW_IMAGE
          value: $(tasks.build-container.results.IMAGE_URL)
        - name: MANIFEST_TYPE
          value: "kustomize"
        - name: CREATE_PR
          value: $(params.CREATE_PR)
        - name: COMMIT_MESSAGE
          value: "chore: update $(params.SERVICE_NAME) image to $(params.IMAGE_TAG) in $(params.ENVIRONMENT)"
      workspaces:
        - name: manifest-repo
          workspace: gitops-workspace

    # 8. Integration tests (optional, post-deployment)
    - name: integration-tests
      taskRef:
        name: maven
        kind: ClusterTask
      runAfter: ["update-gitops-manifests"]
      when:
        - input: "$(params.ENVIRONMENT)"
          operator: in
          values: ["dev", "staging"]
      params:
        - name: GOALS
          value: ["verify", "-Pintegration-tests"]
        - name: MAVEN_IMAGE
          value: "eclipse-temurin:$(params.JAVA_VERSION)-jdk"
      workspaces:
        - name: source
          workspace: source-workspace
        - name: maven-settings
          workspace: cache-workspace

  finally:
    # Pipeline cleanup
    - name: cleanup-workspace
      taskSpec:
        steps:
          - name: cleanup
            image: alpine:3.18
            script: |
              #!/bin/sh
              echo "üßπ Cleaning up pipeline workspace..."
              echo "Service: $(params.SERVICE_NAME)"
              echo "Environment: $(params.ENVIRONMENT)"
              echo "Image: $(tasks.build-container.results.IMAGE_URL)"
              echo "GitOps Commit: $(tasks.update-gitops-manifests.results.COMMIT_SHA)"
              
              # Clean up temporary files
              find /tmp -name "tekton-*" -type f -delete 2>/dev/null || true
              
              echo "‚úÖ Cleanup completed"

    # Send Slack notification on failure
    - name: failure-notification
      when:
        - input: "$(tasks.status)"
          operator: in
          values: ["Failed"]
      taskSpec:
        params:
          - name: WEBHOOK_SECRET
            description: Slack webhook secret name
            default: "slack-webhook-secret"
        steps:
          - name: notify-failure
            image: curlimages/curl:8.2.1
            env:
              - name: SLACK_WEBHOOK_URL
                valueFrom:
                  secretKeyRef:
                    name: $(params.WEBHOOK_SECRET)
                    key: webhook-url
                    optional: true
            script: |
              #!/bin/sh
              echo "üö® Pipeline failed for service: $(params.SERVICE_NAME)"
              
              # Send Slack notification if webhook is configured
              if [ -n "$SLACK_WEBHOOK_URL" ]; then
                echo "üì§ Sending Slack notification..."
                
                # Determine failed task
                FAILED_TASK="unknown"
                if [ "$(tasks.clone-source.status)" = "Failed" ]; then
                  FAILED_TASK="source-clone"
                elif [ "$(tasks.build-application.status)" = "Failed" ]; then
                  FAILED_TASK="build"
                elif [ "$(tasks.run-unit-tests.status)" = "Failed" ]; then
                  FAILED_TASK="tests"
                elif [ "$(tasks.build-container.status)" = "Failed" ]; then
                  FAILED_TASK="container-build"
                elif [ "$(tasks.security-scan.status)" = "Failed" ]; then
                  FAILED_TASK="security-scan"
                elif [ "$(tasks.update-gitops-manifests.status)" = "Failed" ]; then
                  FAILED_TASK="gitops-update"
                fi
                
                curl -X POST -H 'Content-type: application/json' \
                  --data "{
                    \"text\": \"üö® EcoTrack Pipeline Failed\",
                    \"attachments\": [{
                      \"color\": \"danger\",
                      \"fields\": [
                        {\"title\": \"Service\", \"value\": \"$(params.SERVICE_NAME)\", \"short\": true},
                        {\"title\": \"Environment\", \"value\": \"$(params.ENVIRONMENT)\", \"short\": true},
                        {\"title\": \"Failed Task\", \"value\": \"$FAILED_TASK\", \"short\": true},
                        {\"title\": \"Branch\", \"value\": \"$(params.SOURCE_BRANCH)\", \"short\": true},
                        {\"title\": \"Repository\", \"value\": \"$(params.SOURCE_REPO_URL)\", \"short\": false}
                      ]
                    }]
                  }" \
                  "$SLACK_WEBHOOK_URL"
                
                echo "‚úÖ Notification sent"
              else
                echo "‚ÑπÔ∏è No Slack webhook configured"
              fi

    # Send success notification
    - name: success-notification
      when:
        - input: "$(tasks.status)"
          operator: in
          values: ["Succeeded"]
      taskSpec:
        params:
          - name: WEBHOOK_SECRET
            description: Slack webhook secret name
            default: "slack-webhook-secret"
        steps:
          - name: notify-success
            image: curlimages/curl:8.2.1
            env:
              - name: SLACK_WEBHOOK_URL
                valueFrom:
                  secretKeyRef:
                    name: $(params.WEBHOOK_SECRET)
                    key: webhook-url
                    optional: true
            script: |
              #!/bin/sh
              echo "‚úÖ Pipeline succeeded for service: $(params.SERVICE_NAME)"
              
              # Send Slack notification if webhook is configured
              if [ -n "$SLACK_WEBHOOK_URL" ]; then
                echo "üì§ Sending Slack notification..."
                
                # Calculate pipeline duration
                START_TIME="$(context.pipelineRun.metadata.creationTimestamp)"
                
                curl -X POST -H 'Content-type: application/json' \
                  --data "{
                    \"text\": \"‚úÖ EcoTrack Pipeline Succeeded\",
                    \"attachments\": [{
                      \"color\": \"good\",
                      \"fields\": [
                        {\"title\": \"Service\", \"value\": \"$(params.SERVICE_NAME)\", \"short\": true},
                        {\"title\": \"Environment\", \"value\": \"$(params.ENVIRONMENT)\", \"short\": true},
                        {\"title\": \"Image Tag\", \"value\": \"$(params.IMAGE_TAG)\", \"short\": true},
                        {\"title\": \"Branch\", \"value\": \"$(params.SOURCE_BRANCH)\", \"short\": true},
                        {\"title\": \"Image\", \"value\": \"$(tasks.build-container.results.IMAGE_URL)\", \"short\": false},
                        {\"title\": \"GitOps Commit\", \"value\": \"$(tasks.update-gitops-manifests.results.COMMIT_SHA)\", \"short\": false}
                      ]
                    }]
                  }" \
                  "$SLACK_WEBHOOK_URL"
                
                echo "‚úÖ Notification sent"
              else
                echo "‚ÑπÔ∏è No Slack webhook configured"
              fi

    # Update GitHub commit status
    - name: update-github-status
      taskSpec:
        params:
          - name: GIT_TOKEN_SECRET
            description: GitHub token secret name
            default: "git-credentials"
        steps:
          - name: update-status
            image: alpine:3.18
            env:
              - name: GITHUB_TOKEN
                valueFrom:
                  secretKeyRef:
                    name: $(params.GIT_TOKEN_SECRET)
                    key: token
                    optional: true
            script: |
              #!/bin/sh
              echo "üìã Updating GitHub commit status..."
              
              if [ -z "$GITHUB_TOKEN" ]; then
                echo "‚ÑπÔ∏è No GitHub token configured, skipping status update"
                exit 0
              fi
              
              # Extract repository info from URL
              REPO_URL="$(params.SOURCE_REPO_URL)"
              REPO_PATH=$(echo "$REPO_URL" | sed 's|.*github.com/||' | sed 's|.git$||')
              
              # Determine status
              if [ "$(tasks.status)" = "Succeeded" ]; then
                STATE="success"
                DESCRIPTION="Pipeline completed successfully"
              else
                STATE="failure"
                DESCRIPTION="Pipeline failed"
              fi
              
              echo "üîÑ Setting status to: $STATE"
              echo "üìÇ Repository: $REPO_PATH"
              echo "üìù Description: $DESCRIPTION"
              
              # Install curl if needed
              apk add --no-cache curl
              
              # Update commit status
              curl -X POST \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/$REPO_PATH/statuses/$(params.SOURCE_REVISION)" \
                -d "{
                  \"state\": \"$STATE\",
                  \"description\": \"$DESCRIPTION\",
                  \"context\": \"tekton/$(params.SERVICE_NAME)\"
                }"
              
              echo "‚úÖ GitHub status updated"