name: Trigger Tekton Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '.gitignore'

env:
  TEKTON_NAMESPACE: tekton-pipelines
  SERVICE_NAME: ${{ github.event.repository.name }}
  
jobs:
  trigger-pipeline:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action == 'opened' || github.event.action == 'synchronize')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION || 'us-east-1' }} --name ${{ secrets.EKS_CLUSTER_NAME || 'eks-learning-lab-dev' }}

    - name: Verify cluster access
      run: |
        kubectl cluster-info
        kubectl get nodes

    - name: Set environment variables
      run: |
        echo "IMAGE_TAG=$(echo ${{ github.sha }} | cut -c1-8)" >> $GITHUB_ENV
        echo "GIT_REVISION=${{ github.sha }}" >> $GITHUB_ENV
        echo "GIT_BRANCH=${GITHUB_REF#refs/heads/}" >> $GITHUB_ENV
        echo "BUILD_ID=${{ github.run_number }}" >> $GITHUB_ENV
        
        # Determine environment based on branch
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "TARGET_ENV=prod" >> $GITHUB_ENV
        elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
          echo "TARGET_ENV=staging" >> $GITHUB_ENV
        else
          echo "TARGET_ENV=dev" >> $GITHUB_ENV
        fi

    - name: Determine Java version
      id: java-version
      run: |
        # Check if pom.xml exists and extract Java version
        if [ -f "pom.xml" ]; then
          JAVA_VERSION=$(grep -oP '(?<=<java.version>)[^<]+' pom.xml || echo "17")
        elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
          # For Gradle projects, default to 17
          JAVA_VERSION="17"
        else
          JAVA_VERSION="17"
        fi
        echo "java-version=$JAVA_VERSION" >> $GITHUB_OUTPUT
        echo "JAVA_VERSION=$JAVA_VERSION" >> $GITHUB_ENV

    - name: Check for native build configuration
      id: native-check
      run: |
        ENABLE_NATIVE="false"
        if [ -f "pom.xml" ]; then
          if grep -q "native-maven-plugin\|spring-boot-maven-plugin" pom.xml; then
            if grep -q "native" pom.xml; then
              ENABLE_NATIVE="true"
            fi
          fi
        fi
        echo "enable-native=$ENABLE_NATIVE" >> $GITHUB_OUTPUT
        echo "ENABLE_NATIVE=$ENABLE_NATIVE" >> $GITHUB_ENV

    - name: Create PipelineRun
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: tekton.dev/v1beta1
        kind: PipelineRun
        metadata:
          generateName: ${SERVICE_NAME}-${BUILD_ID}-
          namespace: ${TEKTON_NAMESPACE}
          labels:
            app.kubernetes.io/name: ${SERVICE_NAME}
            app.kubernetes.io/instance: ${GIT_REVISION}
            tekton.dev/pipeline: microservice-pipeline
            git.repo: ${SERVICE_NAME}
            git.revision: ${GIT_REVISION}
            git.branch: ${GIT_BRANCH}
            environment: ${TARGET_ENV}
            triggered-by: github-actions
          annotations:
            github.com/repo: ${{ github.repository }}
            github.com/run-id: "${{ github.run_id }}"
            github.com/run-number: "${{ github.run_number }}"
            github.com/actor: "${{ github.actor }}"
            github.com/event-name: "${{ github.event_name }}"
        spec:
          serviceAccountName: tekton-build-sa
          pipelineRef:
            name: microservice-pipeline
          params:
            - name: SOURCE_REPO_URL
              value: ${{ github.server_url }}/${{ github.repository }}
            - name: SOURCE_REVISION
              value: ${GIT_REVISION}
            - name: SERVICE_NAME
              value: ${SERVICE_NAME}
            - name: IMAGE_REPOSITORY
              value: "ecotrack/${SERVICE_NAME}"
            - name: IMAGE_TAG
              value: "${IMAGE_TAG}"
            - name: MANIFEST_REPO_URL
              value: "${{ secrets.MANIFEST_REPO_URL || 'https://github.com/your-org/ecotrack-manifests.git' }}"
            - name: ENVIRONMENT
              value: ${TARGET_ENV}
            - name: JAVA_VERSION
              value: "${JAVA_VERSION}"
            - name: ENABLE_NATIVE_BUILD
              value: "${ENABLE_NATIVE}"
            - name: RUN_TESTS
              value: "true"
            - name: SECURITY_SCAN_ENABLED
              value: "true"
            - name: AUTO_DEPLOY
              value: "${{ github.ref == 'refs/heads/main' && 'true' || 'false' }}"
          workspaces:
            - name: source-workspace
              volumeClaimTemplate:
                spec:
                  accessModes:
                    - ReadWriteOnce
                  resources:
                    requests:
                      storage: 2Gi
                  storageClassName: gp3
            - name: cache-workspace
              volumeClaimTemplate:
                spec:
                  accessModes:
                    - ReadWriteOnce
                  resources:
                    requests:
                      storage: 10Gi
                  storageClassName: gp3
            - name: manifest-workspace
              volumeClaimTemplate:
                spec:
                  accessModes:
                    - ReadWriteOnce
                  resources:
                    requests:
                      storage: 1Gi
                  storageClassName: gp3
          timeout: "2h0m0s"
        EOF

    - name: Get PipelineRun name
      id: get-pipelinerun
      run: |
        sleep 5  # Wait for PipelineRun to be created
        PIPELINERUN_NAME=$(kubectl get pipelinerun -n ${TEKTON_NAMESPACE} \
          -l git.revision=${GIT_REVISION} \
          -l triggered-by=github-actions \
          --sort-by='.metadata.creationTimestamp' \
          -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "")
        
        if [ -n "$PIPELINERUN_NAME" ]; then
          echo "pipelinerun-name=$PIPELINERUN_NAME" >> $GITHUB_OUTPUT
          echo "✅ PipelineRun created: $PIPELINERUN_NAME"
        else
          echo "❌ Failed to get PipelineRun name"
          exit 1
        fi

    - name: Wait for pipeline completion
      id: wait-pipeline
      if: github.event_name == 'push'
      timeout-minutes: 120
      run: |
        PIPELINERUN_NAME="${{ steps.get-pipelinerun.outputs.pipelinerun-name }}"
        
        echo "⏳ Waiting for PipelineRun $PIPELINERUN_NAME to complete..."
        
        while true; do
          STATUS=$(kubectl get pipelinerun $PIPELINERUN_NAME -n ${TEKTON_NAMESPACE} -o jsonpath='{.status.conditions[0].status}' 2>/dev/null || echo "Unknown")
          REASON=$(kubectl get pipelinerun $PIPELINERUN_NAME -n ${TEKTON_NAMESPACE} -o jsonpath='{.status.conditions[0].reason}' 2>/dev/null || echo "Unknown")
          
          echo "Pipeline status: $STATUS ($REASON)"
          
          if [ "$STATUS" = "True" ] && [ "$REASON" = "Succeeded" ]; then
            echo "✅ Pipeline completed successfully!"
            echo "pipeline-status=success" >> $GITHUB_OUTPUT
            break
          elif [ "$STATUS" = "False" ] && [ "$REASON" = "Failed" ]; then
            echo "❌ Pipeline failed!"
            echo "pipeline-status=failed" >> $GITHUB_OUTPUT
            break
          elif [ "$REASON" = "PipelineRunTimeout" ]; then
            echo "⏰ Pipeline timed out!"
            echo "pipeline-status=timeout" >> $GITHUB_OUTPUT
            break
          fi
          
          sleep 30
        done

    - name: Get pipeline logs on failure
      if: steps.wait-pipeline.outputs.pipeline-status == 'failed' && github.event_name == 'push'
      run: |
        PIPELINERUN_NAME="${{ steps.get-pipelinerun.outputs.pipelinerun-name }}"
        echo "📋 Pipeline logs for failed run:"
        kubectl logs pipelinerun/$PIPELINERUN_NAME -n ${TEKTON_NAMESPACE} --all-containers || true

    - name: Post results to PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const pipelinerunName = '${{ steps.get-pipelinerun.outputs.pipelinerun-name }}';
          const tektonDashboardUrl = '${{ secrets.TEKTON_DASHBOARD_URL || 'https://tekton.your-domain.com' }}';
          
          const body = `## 🚀 Tekton Pipeline Triggered
          
          **Service:** ${process.env.SERVICE_NAME}
          **Environment:** ${process.env.TARGET_ENV}
          **Java Version:** ${process.env.JAVA_VERSION}
          **Native Build:** ${process.env.ENABLE_NATIVE}
          **PipelineRun:** \`${pipelinerunName}\`
          
          📊 [View in Tekton Dashboard](${tektonDashboardUrl}/#/namespaces/${process.env.TEKTON_NAMESPACE}/pipelineruns/${pipelinerunName})
          
          The pipeline will build, test, and scan your application. Deployment to ${process.env.TARGET_ENV} will occur automatically if this PR is merged to main.`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });

    - name: Update deployment status
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: actions/github-script@v7
      with:
        script: |
          const status = '${{ steps.wait-pipeline.outputs.pipeline-status }}';
          const pipelinerunName = '${{ steps.get-pipelinerun.outputs.pipelinerun-name }}';
          const tektonDashboardUrl = '${{ secrets.TEKTON_DASHBOARD_URL || 'https://tekton.your-domain.com' }}';
          const argoCdUrl = '${{ secrets.ARGOCD_URL || 'https://argocd.your-domain.com' }}';
          
          let state, description;
          if (status === 'success') {
            state = 'success';
            description = '✅ Pipeline completed successfully and application deployed';
          } else if (status === 'failed') {
            state = 'failure';
            description = '❌ Pipeline failed - check logs for details';
          } else {
            state = 'error';
            description = '⏰ Pipeline timed out or unknown error occurred';
          }
          
          github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: context.sha,
            state: state,
            target_url: `${tektonDashboardUrl}/#/namespaces/${process.env.TEKTON_NAMESPACE}/pipelineruns/${pipelinerunName}`,
            description: description,
            context: 'ci/tekton-pipeline'
          });

  notify-slack:
    runs-on: ubuntu-latest
    needs: trigger-pipeline
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Notify Slack
      if: env.SLACK_WEBHOOK_URL != ''
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      uses: actions/github-script@v7
      with:
        script: |
          const webhook = process.env.SLACK_WEBHOOK_URL;
          if (!webhook) return;
          
          const status = '${{ needs.trigger-pipeline.result }}';
          const color = status === 'success' ? 'good' : 'danger';
          const emoji = status === 'success' ? '✅' : '❌';
          
          const payload = {
            attachments: [{
              color: color,
              blocks: [{
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: `${emoji} *Pipeline ${status === 'success' ? 'Completed' : 'Failed'}*\n*Service:* ${process.env.SERVICE_NAME}\n*Branch:* ${process.env.GIT_BRANCH}\n*Commit:* \`${process.env.GIT_REVISION}\`\n*Environment:* ${process.env.TARGET_ENV}`
                }
              }, {
                type: 'actions',
                elements: [{
                  type: 'button',
                  text: { type: 'plain_text', text: 'View Pipeline' },
                  url: '${{ secrets.TEKTON_DASHBOARD_URL || 'https://tekton.your-domain.com' }}'
                }, {
                  type: 'button',
                  text: { type: 'plain_text', text: 'View Deployment' },
                  url: '${{ secrets.ARGOCD_URL || 'https://argocd.your-domain.com' }}'
                }]
              }]
            }]
          };
          
          await fetch(webhook, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
